11 December 2013 11:37:51 PM

SUBSET_PRB
  C++ version
  Test the SUBSET library.

TEST000
  Call RANDOM_INITIALIZE to initialize the
  RANDOM random number generator.

RANDOM_INITIALIZE
  Initialize RANDOM with arbitrary SEED = 3805022877

  RANDOM_INITIALIZE returns SEED = 3805022877

TEST001
  ASM_ENUM returns the number of alternating sign
  matrices of a given order.

   0       1
   1       1
   2       2
   3       7
   4      42
   5     429
   6    7436
   7  218348

TEST002
  ASM_TRIANGLE returns a row of the alternating sign
  matrix triangle.

   0         1  
   1         1         1  
   2         2         3         2  
   3         7        14        14         7  
   4        42       105       135       105        42  
   5       429      1287      2002      2002      1287       429  
   6      7436     26026     47320     56784     47320     26026      7436  
   7    218348    873392   1813968   2519400   2519400   1813968    873392    218348  

TEST003
  BELL computes Bell numbers.
  BELL_VALUES returns some exact values.

  N  exact C(I)  computed C(I)

     0         1         1
     1         1         1
     2         2         2
     3         5         5
     4        15        15
     5        52        52
     6       203       203
     7       877       877
     8      4140      4140
     9     21147     21147
    10    115975    115975

TEST9001
  BVEC_ADD adds binary vectors representing integers;
  BVEC_SUB subtracts binary vectors representing integers;

        I        J        K = I + J    L = I - J


       -57        92
  Directly:                 35      -149
  BVEC_ADD, BVEC_SUB        35      -149

        66        12
  Directly:                 78        54
  BVEC_ADD, BVEC_SUB        78        54

       -17       -87
  Directly:               -104        70
  BVEC_ADD, BVEC_SUB      -104        70

       -49       -78
  Directly:               -127        29
  BVEC_ADD, BVEC_SUB      -127        29

       -92        27
  Directly:                -65      -119
  BVEC_ADD, BVEC_SUB       -65      -119

       -88       -10
  Directly:                -98       -78
  BVEC_ADD, BVEC_SUB       -98       -78

       -20        51
  Directly:                 31       -71
  BVEC_ADD, BVEC_SUB        31       -71

        60      -100
  Directly:                -40       160
  BVEC_ADD, BVEC_SUB       -40       160

        80       -30
  Directly:                 50       110
  BVEC_ADD, BVEC_SUB        50       110

       -81       -98
  Directly:               -179        17
  BVEC_ADD, BVEC_SUB      -179        17

TEST9002
  BVEC_COMPLEMENT2 returns the two's complement
  of a (signed) binary vector;


  I =   -57
  J =   57

 

   1111000111

 

   0000111001

  I =   92
  J =   -92

 

   0001011100

 

   1110100100

  I =   66
  J =   -66

 

   0001000010

 

   1110111110

  I =   12
  J =   -12

 

   0000001100

 

   1111110100

  I =   -17
  J =   17

 

   1111101111

 

   0000010001

TEST9003
  BVEC_MUL multiplies binary vectors
  representing integers;

        I        J        K = I * J


       -57        92
  Directly:              -5244
  BVEC_MUL               -5244

        66        12
  Directly:                792
  BVEC_MUL                 792

       -17       -87
  Directly:               1479
  BVEC_MUL                1479

       -49       -78
  Directly:               3822
  BVEC_MUL                3822

       -92        27
  Directly:              -2484
  BVEC_MUL               -2484

       -88       -10
  Directly:                880
  BVEC_MUL                 880

       -20        51
  Directly:              -1020
  BVEC_MUL               -1020

        60      -100
  Directly:              -6000
  BVEC_MUL               -6000

        80       -30
  Directly:              -2400
  BVEC_MUL               -2400

       -81       -98
  Directly:               7938
  BVEC_MUL                7938

TEST005
  CATALAN computes Catalan numbers.
  CATALAN_VALUES returns some exact values.

  N  exact C(I)  computed C(I)

     0         1         1
     1         1         1
     2         2         2
     3         5         5
     4        14        14
     5        42        42
     6       132       132
     7       429       429
     8      1430      1430
     9      4862      4862
    10     16796     16796

TEST006
  CATALAN_ROW_NEXT computes a row of the Catalan triangle.

  First, compute row 7:
   7         1         7        27        75       165       297       429       429  

  Now compute rows consecutively, one at a time:

   0       1  
   1       1       1  
   2       1       2       2  
   3       1       3       5       5  
   4       1       4       9      14      14  
   5       1       5      14      28      42      42  
   6       1       6      20      48      90     132     132  
   7       1       7      27      75     165     297     429     429  
   8       1       8      35     110     275     572    1001    1430    1430  
   9       1       9      44     154     429    1001    2002    3432    4862    4862  
  10       1      10      54     208     637    1638    3640    7072   11934   16796   16796  

TEST007
  RAT_TO_CFRAC fraction => continued fraction,
  CFRAC_TO_RAT continued fraction => fraction.

  Regular fraction is 4096/15625

  Continued fraction coefficients:

       1         0
       2         3
       3         1
       4         4
       5         2
       6         1
       7         1
       8        11
       9        13

  The continued fraction convergents.
  The last row contains the value of the continued
  fraction, written as a common fraction.

  I, P(I), Q(I), P(I)/Q(I)

  0       0       1               0
  1       1       3        0.333333
  2       1       4            0.25
  3       5      19        0.263158
  4      11      42        0.261905
  5      16      61        0.262295
  6      27     103        0.262136
  7     313    1194        0.262144
  8    4096   15625        0.262144

TEST008
  CFRAC_TO_RFRAC: continued fraction to ratio;
  RFRAC_TO_CFRAC: ratio to continued fration.

  Rational polynomial fraction coefficients:

  P:             1           1           2
  Q:             1           3           1           1

  Continued fraction coefficients:

         0             1
         1           0.5
         2       1.33333
         3          -0.5
         4          -1.5
         5             2

  Recovered rational polynomial:

  P:             1           1           2
  Q:             1           3           1           1

TEST009
  CHANGE_GREEDY makes change using the biggest
  coins first.

  The total for which change is to be made: 73

  The available coins are:

     1
     5
    10
    25
    50
   100

  The number of coins in change is: 6

          4    2    2    0    0    0  
    73   50   10   10    1    1    1  

TEST010
  CHANGE_NEXT displays the next possible way to make
  change for a given total

  The total for which change is to be made: 50


  The available coins are:

     1
     5
    10
    25
    50
   100

  1
 50  

  2
 25   25  

  3
 25   10   10    5  

  4
 25   10   10    1    1    1    1    1  

  5
 25   10    5    5    5  

  6
 25   10    5    5    1    1    1    1    1  

  7
 25   10    5    1    1    1    1    1    1    1    1    1    1  

  8
 25   10    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  

  9
 25    5    5    5    5    5  

 10
 25    5    5    5    5    1    1    1    1    1  

TEST011
  COMB_NEXT produces combinations.

  Combinations of size K = 1

     1
     2
     3
     4
     5

  Combinations of size K = 2

     1     2
     1     3
     1     4
     1     5
     2     3
     2     4
     2     5
     3     4
     3     5
     4     5

  Combinations of size K = 3

     1     2     3
     1     2     4
     1     2     5
     1     3     4
     1     3     5
     1     4     5
     2     3     4
     2     3     5
     2     4     5
     3     4     5

  Combinations of size K = 4

     1     2     3     4
     1     2     3     5
     1     2     4     5
     1     3     4     5
     2     3     4     5

  Combinations of size K = 5

     1     2     3     4     5

TEST012
  COMB_ROW computes a row of the Pascal triangle.

   0      1
   1      1    1
   2      1    2    1
   3      1    3    3    1
   4      1    4    6    4    1
   5      1    5   10   10    5    1
   6      1    6   15   20   15    6    1
   7      1    7   21   35   35   21    7    1
   8      1    8   28   56   70   56   28    8    1
   9      1    9   36   84  126  126   84   36    9    1
  10      1   10   45  120  210  252  210  120   45   10    1

TEST013
  COMB_UNRANK returns a combination of N things
  out of M, given the lexicographic rank.

  The total set size is M = 10
  The subset size is N =    5
  The number of combinations of N out of M is 252

   Rank	  Combination

    1     1     2     3     4     5  
    2     1     2     3     4     6  
    3     1     2     3     4     7  
  6     1     2     3     4    10  
  7     1     2     3     5     6  
  8     1     2     3     5     7  
  250     5     6     8     9    10  
  251     5     7     8     9    10  
  252     6     7     8     9    10  

TEST014
  R8_CHOOSE evaluates C(N,K).

     N     K    CNK

     0       0       1
     1       0       1
     1       1       1
     2       0       1
     2       1       2
     2       2       1
     3       0       1
     3       1       3
     3       2       3
     3       3       1
     4       0       1
     4       1       4
     4       2       6
     4       3       4
     4       4       1

TEST015
  I4_CHOOSE evaluates C(N,K).

     N     K    CNK

     0       0       1
     1       0       1
     1       1       1
     2       0       1
     2       1       2
     2       2       1
     3       0       1
     3       1       3
     3       2       3
     3       3       1
     4       0       1
     4       1       4
     4       2       6
     4       3       4
     4       4       1

TEST016
  COMP_NEXT produces compositions.

  Seeking all compositions of N = 6
  using 3 parts.

       1     6     0     0  
       2     5     1     0  
       3     4     2     0  
       4     3     3     0  
       5     2     4     0  
       6     1     5     0  
       7     0     6     0  
       8     5     0     1  
       9     4     1     1  
      10     3     2     1  
      11     2     3     1  
      12     1     4     1  
      13     0     5     1  
      14     4     0     2  
      15     3     1     2  
      16     2     2     2  
      17     1     3     2  
      18     0     4     2  
      19     3     0     3  
      20     2     1     3  
      21     1     2     3  
      22     0     3     3  
      23     2     0     4  
      24     1     1     4  
      25     0     2     4  
      26     1     0     5  
      27     0     1     5  
      28     0     0     6  

TEST017
  COMP_RANDOM produces compositions at random.

  Seeking random compositions of N = 10
  using 5 parts.

     3     3     2     0     2  
     2     0     2     2     4  
     2     1     5     0     2  
     2     1     4     2     1  
     1     2     3     1     3  

TEST01705
  A COMP is a composition of an integer N into K parts.
  Each part is nonnegative.  The order matters.
  COMP_NEXT_GRLEX determines the next COMP in
  graded lexicographic (grlex) order.

  Rank:     NC       COMP
  ----:     --   ------------
     1:      0 =  0 +  0 +  0
  ----:     --   ------------
     2:      1 =  0 +  0 +  1
     3:      1 =  0 +  1 +  0
     4:      1 =  1 +  0 +  0
  ----:     --   ------------
     5:      2 =  0 +  0 +  2
     6:      2 =  0 +  1 +  1
     7:      2 =  0 +  2 +  0
     8:      2 =  1 +  0 +  1
     9:      2 =  1 +  1 +  0
    10:      2 =  2 +  0 +  0
  ----:     --   ------------
    11:      3 =  0 +  0 +  3
    12:      3 =  0 +  1 +  2
    13:      3 =  0 +  2 +  1
    14:      3 =  0 +  3 +  0
    15:      3 =  1 +  0 +  2
    16:      3 =  1 +  1 +  1
    17:      3 =  1 +  2 +  0
    18:      3 =  2 +  0 +  1
    19:      3 =  2 +  1 +  0
    20:      3 =  3 +  0 +  0
  ----:     --   ------------
    21:      4 =  0 +  0 +  4
    22:      4 =  0 +  1 +  3
    23:      4 =  0 +  2 +  2
    24:      4 =  0 +  3 +  1
    25:      4 =  0 +  4 +  0
    26:      4 =  1 +  0 +  3
    27:      4 =  1 +  1 +  2
    28:      4 =  1 +  2 +  1
    29:      4 =  1 +  3 +  0
    30:      4 =  2 +  0 +  2
    31:      4 =  2 +  1 +  1
    32:      4 =  2 +  2 +  0
    33:      4 =  3 +  0 +  1
    34:      4 =  3 +  1 +  0
    35:      4 =  4 +  0 +  0
  ----:     --   ------------
    36:      5 =  0 +  0 +  5
    37:      5 =  0 +  1 +  4
    38:      5 =  0 +  2 +  3
    39:      5 =  0 +  3 +  2
    40:      5 =  0 +  4 +  1
    41:      5 =  0 +  5 +  0
    42:      5 =  1 +  0 +  4
    43:      5 =  1 +  1 +  3
    44:      5 =  1 +  2 +  2
    45:      5 =  1 +  3 +  1
    46:      5 =  1 +  4 +  0
    47:      5 =  2 +  0 +  3
    48:      5 =  2 +  1 +  2
    49:      5 =  2 +  2 +  1
    50:      5 =  2 +  3 +  0
    51:      5 =  3 +  0 +  2
    52:      5 =  3 +  1 +  1
    53:      5 =  3 +  2 +  0
    54:      5 =  4 +  0 +  1
    55:      5 =  4 +  1 +  0
    56:      5 =  5 +  0 +  0
  ----:     --   ------------
    57:      6 =  0 +  0 +  6
    58:      6 =  0 +  1 +  5
    59:      6 =  0 +  2 +  4
    60:      6 =  0 +  3 +  3
    61:      6 =  0 +  4 +  2
    62:      6 =  0 +  5 +  1
    63:      6 =  0 +  6 +  0
    64:      6 =  1 +  0 +  5
    65:      6 =  1 +  1 +  4
    66:      6 =  1 +  2 +  3
    67:      6 =  1 +  3 +  2
    68:      6 =  1 +  4 +  1
    69:      6 =  1 +  5 +  0
    70:      6 =  2 +  0 +  4
    71:      6 =  2 +  1 +  3

TEST0171
  A COMP is a composition of an integer N into K parts.
  Each part is nonnegative.  The order matters.
  COMP_RANK_GRLEX determines the rank of a COMP
  from its parts.
  COMP_UNRANK_GRLEX determines the parts
  of a COMP from its rank.

  Rank: ->  NC       COMP    -> : Rank
  ----:     --   ------------   : ----
     1:      0 =  0 +  0 +  0   :    1
  ----:     --   ------------   : ----
     2:      1 =  0 +  0 +  1   :    2
     3:      1 =  0 +  1 +  0   :    3
     4:      1 =  1 +  0 +  0   :    4
  ----:     --   ------------   : ----
     5:      2 =  0 +  0 +  2   :    5
     6:      2 =  0 +  1 +  1   :    6
     7:      2 =  0 +  2 +  0   :    7
     8:      2 =  1 +  0 +  1   :    8
     9:      2 =  1 +  1 +  0   :    9
    10:      2 =  2 +  0 +  0   :   10
  ----:     --   ------------   : ----
    11:      3 =  0 +  0 +  3   :   11
    12:      3 =  0 +  1 +  2   :   12
    13:      3 =  0 +  2 +  1   :   13
    14:      3 =  0 +  3 +  0   :   14
    15:      3 =  1 +  0 +  2   :   15
    16:      3 =  1 +  1 +  1   :   16
    17:      3 =  1 +  2 +  0   :   17
    18:      3 =  2 +  0 +  1   :   18
    19:      3 =  2 +  1 +  0   :   19
    20:      3 =  3 +  0 +  0   :   20
  ----:     --   ------------   : ----
    21:      4 =  0 +  0 +  4   :   21
    22:      4 =  0 +  1 +  3   :   22
    23:      4 =  0 +  2 +  2   :   23
    24:      4 =  0 +  3 +  1   :   24
    25:      4 =  0 +  4 +  0   :   25
    26:      4 =  1 +  0 +  3   :   26
    27:      4 =  1 +  1 +  2   :   27
    28:      4 =  1 +  2 +  1   :   28
    29:      4 =  1 +  3 +  0   :   29
    30:      4 =  2 +  0 +  2   :   30
    31:      4 =  2 +  1 +  1   :   31
    32:      4 =  2 +  2 +  0   :   32
    33:      4 =  3 +  0 +  1   :   33
    34:      4 =  3 +  1 +  0   :   34
    35:      4 =  4 +  0 +  0   :   35
  ----:     --   ------------   : ----
    36:      5 =  0 +  0 +  5   :   36
    37:      5 =  0 +  1 +  4   :   37
    38:      5 =  0 +  2 +  3   :   38
    39:      5 =  0 +  3 +  2   :   39
    40:      5 =  0 +  4 +  1   :   40
    41:      5 =  0 +  5 +  0   :   41
    42:      5 =  1 +  0 +  4   :   42
    43:      5 =  1 +  1 +  3   :   43
    44:      5 =  1 +  2 +  2   :   44
    45:      5 =  1 +  3 +  1   :   45
    46:      5 =  1 +  4 +  0   :   46
    47:      5 =  2 +  0 +  3   :   47
    48:      5 =  2 +  1 +  2   :   48
    49:      5 =  2 +  2 +  1   :   49
    50:      5 =  2 +  3 +  0   :   50
    51:      5 =  3 +  0 +  2   :   51
    52:      5 =  3 +  1 +  1   :   52
    53:      5 =  3 +  2 +  0   :   53
    54:      5 =  4 +  0 +  1   :   54
    55:      5 =  4 +  1 +  0   :   55
    56:      5 =  5 +  0 +  0   :   56
  ----:     --   ------------   : ----
    57:      6 =  0 +  0 +  6   :   57
    58:      6 =  0 +  1 +  5   :   58
    59:      6 =  0 +  2 +  4   :   59
    60:      6 =  0 +  3 +  3   :   60
    61:      6 =  0 +  4 +  2   :   61
    62:      6 =  0 +  5 +  1   :   62
    63:      6 =  0 +  6 +  0   :   63
    64:      6 =  1 +  0 +  5   :   64
    65:      6 =  1 +  1 +  4   :   65
    66:      6 =  1 +  2 +  3   :   66
    67:      6 =  1 +  3 +  2   :   67
    68:      6 =  1 +  4 +  1   :   68
    69:      6 =  1 +  5 +  0   :   69
    70:      6 =  2 +  0 +  4   :   70
    71:      6 =  2 +  1 +  3   :   71

TEST0172
  COMP_TO_KSUB returns the K subset corresponding to a composition.
  KSUB_TO_COMP returns the composition corresponding to a K subset.

  COMP:   3   3   2   0   2
  KSUB:   4   8  11  12
  COMP:   3   3   2   0   2

  COMP:   2   0   2   2   4
  KSUB:   3   4   7  10
  COMP:   2   0   2   2   4

  COMP:   2   1   5   0   2
  KSUB:   3   5  11  12
  COMP:   2   1   5   0   2

  COMP:   2   1   4   2   1
  KSUB:   3   5  10  13
  COMP:   2   1   4   2   1

  COMP:   1   2   3   1   3
  KSUB:   2   5   9  11
  COMP:   1   2   3   1   3

TEST0173
  COMPNZ_TO_KSUB returns the K subset corresponding
  to a nonzero composition.
  KSUB_TO_COMPNZ returns the nonzero composition 
  corresponding to a K subset.

  COMPNZ:   1   4   2   1   2
  KSUB:     1   5   7   8
  COMPNZ:   1   4   2   1   2

  COMPNZ:   1   3   1   4   1
  KSUB:     1   4   5   9
  COMPNZ:   1   3   1   4   1

  COMPNZ:   1   1   5   1   2
  KSUB:     1   2   7   8
  COMPNZ:   1   1   5   1   2

  COMPNZ:   3   3   2   1   1
  KSUB:     3   6   8   9
  COMPNZ:   3   3   2   1   1

  COMPNZ:   1   2   3   2   2
  KSUB:     1   3   6   8
  COMPNZ:   1   2   3   2   2

TEST0174
  COMPNZ_NEXT produces compositions using nonzero parts.

  Seeking all compositions of N = 6
  using 3 nonzero parts.

     4     1     1  
     3     2     1  
     2     3     1  
     1     4     1  
     3     1     2  
     2     2     2  
     1     3     2  
     2     1     3  
     1     2     3  
     1     1     4  

TEST0175
  COMPNZ_RANDOM produces compositions at random
  with only nonzero parts.

  Seeking random compositions of N = 10
  using 5 nonzero parts.

     1     4     2     1     2  
     1     3     1     4     1  
     1     1     5     1     2  
     3     3     2     1     1  
     1     2     3     2     2  

TEST018
  CONGRUENCE solves a congruence equation:
    A * X = C mod ( B )

   I        A         B         C         X     Mod ( A*X-C,B)

   1        1027         712          -7         443           0
   2        1027        -712           7       -1155           0
   3        1027        -712          -7         443           0
   4       -1027         712           7         443           0
   5       -1027         712          -7         269           0
   6       -1027        -712           7         443           0
   7       -1027        -712          -7       -1155           0
   8           6           8          50           7           0
   9           0           0           0           0           0
  10           0           1           0           0           0
  11           0           1           1           0           0
  12           1           0           0           0           0
  13           1           0           1           1           0
  14           1           1           0           0           0
  15        1024      -15625       11529      -15629           0
  16           0           0           1  (An error occurred)
  17           0           3          11  (An error occurred)
  18           5           0          19  (An error occurred)
  19           2           4           7  (An error occurred)

TEST019
  COUNT_POSE_RANDOM poses a random problem for
  the game The Count is Good.

  Problem #1

    The goal = 296

    The available numbers are

   1     2     3     5     9    50  

  Problem #2

    The goal = 817

    The available numbers are

   1     2     4     6    50   100  

  Problem #3

    The goal = 605

    The available numbers are

   3     6     8    25    50    75  

  Problem #4

    The goal = 291

    The available numbers are

   1     2     7    10    25   100  

  Problem #5

    The goal = 944

    The available numbers are

   1     2     3     5     8    75  

TEST020
  R8_TO_CFRAC converts a double precision number to
  a sequence of continued fraction convergents.

  Use the real number R = 6.28319

             6             6             1               6        0.283185
             3            19             3         6.33333       -0.050148
             1            25             4            6.25       0.0331853
             1            44             7         6.28571     -0.00252898
             7           333            53         6.28302     0.000166439
             2           710           113         6.28319    -5.33528e-07
           146        103993         16551         6.28319     1.15578e-09
             3        312689         49766         6.28319    -5.82867e-11
             6       1980127        315147         6.28319     5.47384e-12
             1       2292816        364913         6.28319    -3.22142e-12
             1       4272943        680060         6.28319     8.08242e-13

TEST021
  DEBRUIJN computes a de Bruijn string.

  The alphabet size is M = 2
  The string length is N = 3

  21222111

  The alphabet size is M = 3
  The string length is N = 3

  212221132131232231332333111

  The alphabet size is M = 2
  The string length is N = 4

  2121122122221111

TEST022
  DEC_ADD adds two decimals.


  Number of decimal places is 3

  A = 128*10^(-1)
  B = 438*10^(-2)
  C = A + B = 172*10^(-1)

TEST023
  DEC_DIV divides two decimals.

  Number of decimal places is 3

  A = 523*10^(-1)
  B = 134*10^(2)
  C = A / B = 39*10^(-4)

TEST024
  DEC_MUL multiplies two decimals.

  Number of decimal places is 2

  A = 14*10^(-4)
  B = 16*10^(2)
  C = A * B = 22*10^(-1)

TEST025
  DEC_ROUND rounds a decimal to a number of digits.

           -----Before-------  -----After--------
  Digits   Mantissa  Exponent  Mantissa  Exponent

     1     523      -1         5       1
     2     523      -1        52       0
     3     523      -1       523      -1
     4     523      -1       523      -1
     2    6340       2        63       4
     3    6340       2       634       3
     4    6340       2       634       3

TEST026
  RAT_TO_DEC fraction => decimal,
  DEC_TO_RAT decimal => fraction.

  In this test, choose the top and bottom
  of a rational at random, and compute the
  equivalent real number.

  Then convert to decimal, and the equivalent real.

  Then convert back to rational and the equivalent real.

  -0.588297 = -563/957
  -0.588297 = -588296760*10^(-9)
  -0.588297 = -14707419/25000000

  1.1726 = 659/562
  1.1726 = 1172597864*10^(-9)
  1.1726 = 146574733/125000000

  -2.52239 = -169/67
  -2.52239 = -252238805*10^(-8)
  -2.52239 = -50447761/20000000

  -4.40909 = -485/110
  -4.40909 = -440909090*10^(-8)
  -4.40909 = -44090909/10000000

  -1.44006 = -913/634
  -1.44006 = -1440063091*10^(-9)
  -1.44006 = -1440063091/1000000000

  -1.94889 = -877/450
  -1.94889 = -1948888888*10^(-9)
  -1.94889 = -243611111/125000000

  -0.260927 = -197/755
  -0.260927 = -260927152*10^(-9)
  -0.260927 = -16307947/62500000

  297.5 = 595/2
  297.5 = 2975*10^(-1)
  297.5 = 595/2

  2.26496 = 795/351
  2.26496 = 226495726*10^(-8)
  2.26496 = 113247863/50000000

  -57.9286 = -811/14
  -57.9286 = -579285714*10^(-7)
  -57.9286 = -289642857/5000000

TEST027
  DEC_TO_S prints out a decimal.

  Mantissa  Exponent  String

     523        -1  52.3
     134         2  13400
    -134         2  -13400
       0        10  0
  123456        -8  0.00123456
  123456        -7  0.0123456
  123456        -6  0.123456
  123456        -5  1.23456
  123456        -4  12.3456
  123456        -3  123.456
  123456        -2  1234.56
  123456        -1  12345.6
  123456         0  123456
  123456         1  1234560
  123456         2  12345600
  123456         3  123456000

TEST028
  DEC_WIDTH determines the "width" of a decimal.

  Mantissa  Exponent  Width

     523        -1         4
     134         2         5
    -134         2         6
       0        10         1
  123456        -8        10
  123456        -7         9
  123456        -6         8
  123456        -5         7
  123456        -4         7
  123456        -3         7
  123456        -2         7
  123456        -1         7
  123456         0         6
  123456         1         7
  123456         2         8
  123456         3         9

TEST029
  DECMAT_DET: determinant of a decimal matrix.


  The 123/456/789 matrix:

  1    2    3  
  4    5    6  
  7    8    9  

  Determinant of the 123/456/789 matrix = 0* 10^(0)

  The Hilbert matrix:

      0.5    0.33333       0.25        0.2  
  0.33333       0.25        0.2    0.16667  
     0.25        0.2    0.16667    0.14286  
      0.2    0.16667    0.14286      0.125  

  Determinant of the Hilbert matrix = 1* 10^(-7)

  The -1,2,-1 matrix:

   2    -1     0  
  -1     2    -1  
   0    -1     2  

  Determinant of the -1,2,-1 matrix = 4* 10^(0)

TEST021a
  DERANGE_ENUM counts derangements;
  DERANGE_ENUM2 counts derangements.
  DERANGE_ENUM3 counts derangements.

       N    # of derangements

         0         1         1         1
         1         0         0         0
         2         1         1         1
         3         2         2         2
         4         9         9         9
         5        44        44        44
         6       265       265       265
         7      1854      1854      1854
         8     14833     14833     14833
         9    133496    133496    133496
        10   1334961   1334961   1334961

TEST022a
  DERANGE_BACK_NEXT generates derangements
  using backtracking.

   1       5     4     2     3     1  
   2       5     4     2     1     3  
   3       5     4     1     3     2  
   4       5     4     1     2     3  
   5       5     3     4     2     1  
   6       5     3     4     1     2  
   7       5     3     2     1     4  
   8       5     3     1     2     4  
   9       5     1     4     3     2  
  10       5     1     4     2     3  
  11       5     1     2     3     4  
  12       4     5     2     3     1  
  13       4     5     2     1     3  
  14       4     5     1     3     2  
  15       4     5     1     2     3  
  16       4     3     5     2     1  
  17       4     3     5     1     2  
  18       4     3     2     5     1  
  19       4     3     1     5     2  
  20       4     1     5     3     2  
  21       4     1     5     2     3  
  22       4     1     2     5     3  
  23       3     5     4     2     1  
  24       3     5     4     1     2  
  25       3     5     2     1     4  
  26       3     5     1     2     4  
  27       3     4     5     2     1  
  28       3     4     5     1     2  
  29       3     4     2     5     1  
  30       3     4     1     5     2  
  31       3     1     5     2     4  
  32       3     1     4     5     2  
  33       3     1     2     5     4  
  34       2     5     4     3     1  
  35       2     5     4     1     3  
  36       2     5     1     3     4  
  37       2     4     5     3     1  
  38       2     4     5     1     3  
  39       2     4     1     5     3  
  40       2     3     5     1     4  
  41       2     3     4     5     1  
  42       2     3     1     5     4  
  43       2     1     5     3     4  
  44       2     1     4     5     3  

TEST023a
  DERANGE_WEED_NEXT generates derangements
  by generating ALL permutations, and weeding out
  the ones that are not derangements.

   1       2     1     4     5     3  
   2       2     1     5     3     4  
   3       2     3     1     5     4  
   4       2     3     4     5     1  
   5       2     3     5     1     4  
   6       2     4     1     5     3  
   7       2     4     5     1     3  
   8       2     4     5     3     1  
   9       2     5     1     3     4  
  10       2     5     4     1     3  
  11       2     5     4     3     1  
  12       3     1     2     5     4  
  13       3     1     4     5     2  
  14       3     1     5     2     4  
  15       3     4     1     5     2  
  16       3     4     2     5     1  
  17       3     4     5     1     2  
  18       3     4     5     2     1  
  19       3     5     1     2     4  
  20       3     5     2     1     4  
  21       3     5     4     1     2  
  22       3     5     4     2     1  
  23       4     1     2     5     3  
  24       4     1     5     2     3  
  25       4     1     5     3     2  
  26       4     3     1     5     2  
  27       4     3     2     5     1  
  28       4     3     5     1     2  
  29       4     3     5     2     1  
  30       4     5     1     2     3  
  31       4     5     1     3     2  
  32       4     5     2     1     3  
  33       4     5     2     3     1  
  34       5     1     2     3     4  
  35       5     1     4     2     3  
  36       5     1     4     3     2  
  37       5     3     1     2     4  
  38       5     3     2     1     4  
  39       5     3     4     1     2  
  40       5     3     4     2     1  
  41       5     4     1     2     3  
  42       5     4     1     3     2  
  43       5     4     2     1     3  
  44       5     4     2     3     1  

TEST024a
  DIGRAPH_ARC_EULER finds an Euler circuit of a digraph.

  The arc list of the digraph:

     1       2       5
     2       1       4
     3       2       3
     4       1       2
     5       3       1
     6       5       1
     7       4       2

  The edge list of the Euler circuit:

       1         6
       2         4
       3         3
       4         5
       5         2
       6         7
       7         1

  The node list of the Euler circuit:

	 I  Edge  Node

     0       6       1
     1       4       2
     2       3       3
     3       5       1
     4       2       4
     5       7       2
     6       1       5

TEST025a
  DIOPHANTINE solves a Diophantine equation:
    A * X + B * Y = C

        A         B         C         X     Y     Residual

      1027         712           7         269        -388           0
      1027         712          -7        -269         388           0
      1027        -712           7         269         388           0
      1027        -712          -7        -269        -388           0
     -1027         712           7        -269        -388           0
     -1027         712          -7         269         388           0
     -1027        -712           7        -269         388           0
     -1027        -712          -7         269        -388           0
         6           8          50           3           4           0
         0           0           0           0           0           0
         0           1           0           0           0           0
         0           1           1           0           1           0
         1           0           0           0           0           0
         1           0           1           1           0           0
         1           1           0           1          -1           0
      1024      -15625       11529          -4          -1           0
         0           0           1  (Error occurred!)
         0           3          11  (Error occurred!)
         5           0          19  (Error occurred!)
         2           4           7  (Error occurred!)

TEST026a
  DIOPHANTINE_SOLUTION_MINIMIZE computes a minimal
  Euclidean norm solution of a Diophantine equation:
    A * X + B * Y = C

  Coefficients:
    A =         4096
    B =       -15625
    C =        46116
  Solution:
    X =    665499996
    Y =    174456828
  Residual R = A * X + B * Y - C:
    R =            0

  DIOPHANTINE_SOLUTION_MINIMIZE returns
  the minimized solution:
    X =           -4
    Y =           -4
  Residual R = A * X + B * Y - C:
    R =            0

  Here is the minimal positive solution:
    X =        15621
    Y =         4092
  Residual R = A * X + B * Y - C:
    R =            0

TEST026B
  DVEC_ADD adds decimal vectors representing integers;
  DVEC_SUB subtracts decimal vectors representing integers;

        I        J        K = I + J    L = I - J


       -57        92
  Directly:                 35      -149
  DVEC_ADD, DVEC_SUB        -1         1

        66        12
  Directly:                 78        54
  DVEC_ADD, DVEC_SUB        -1        -1

       -17       -87
  Directly:               -104        70
  DVEC_ADD, DVEC_SUB         1        -1

       -49       -78
  Directly:               -127        29
  DVEC_ADD, DVEC_SUB         1        -1

       -92        27
  Directly:                -65      -119
  DVEC_ADD, DVEC_SUB         1         1

       -88       -10
  Directly:                -98       -78
  DVEC_ADD, DVEC_SUB         1         1

       -20        51
  Directly:                 31       -71
  DVEC_ADD, DVEC_SUB        -1         1

        60      -100
  Directly:                -40       160
  DVEC_ADD, DVEC_SUB         1        -1

        80       -30
  Directly:                 50       110
  DVEC_ADD, DVEC_SUB        -1        -1

       -81       -98
  Directly:               -179        17
  DVEC_ADD, DVEC_SUB         1        -1

TEST026C
  DVEC_COMPLEMENTX returns the ten's complement
  of a (signed) decimal vector;


  I =   -57
  J =   -1

 

  9999999943

 

  0000000057

  I =   92
  J =   1

 

  0000000092

 

  9999999908

  I =   66
  J =   1

 

  0000000066

 

  9999999934

  I =   12
  J =   1

 

  0000000012

 

  9999999988

  I =   -17
  J =   -1

 

  9999999983

 

  0000000017

TEST026D
  DVEC_MUL multiplies decimal vectors
  representing integers;

        I        J        K = I * J


      -563       913
  Directly:            -514019
  DVEC_MUL                   1

       659       123
  Directly:              81057
  DVEC_MUL                  -1

      -169      -868
  Directly:             146692
  DVEC_MUL                  -1

      -485      -780
  Directly:             378300
  DVEC_MUL                  -1

      -913       268
  Directly:            -244684
  DVEC_MUL                   1

      -877      -101
  Directly:              88577
  DVEC_MUL                  -1

      -197       510
  Directly:            -100470
  DVEC_MUL                   1

       595      -997
  Directly:            -593215
  DVEC_MUL                   1

       795      -299
  Directly:            -237705
  DVEC_MUL                   1

      -811      -973
  Directly:             789103
  DVEC_MUL                  -1

  NOW REPEAT THE TEST...

  but use too few digits to represent big products.
  This corresponds to an "overflow".
  The result here should get the final decimal
  digits correctly, though.

        I        J        K = I * J


       719       682
  Directly:             490358
  DVEC_MUL            -1305424328

      -754      -985
  Directly:             742690
  DVEC_MUL            -961633963

      -480       825
  Directly:            -396000
  DVEC_MUL            1305424328

      -773      -297
  Directly:             229581
  DVEC_MUL            -1773790777

       646      -466
  Directly:            -301036
  DVEC_MUL                   1

       384       123
  Directly:              47232
  DVEC_MUL            -961633963

       723       -92
  Directly:             -66516
  DVEC_MUL            279019293

       824       196
  Directly:             161504
  DVEC_MUL            -279019293

      -622       523
  Directly:            -325306
  DVEC_MUL            1773790777

      -206      -630
  Directly:             129780
  DVEC_MUL            -1773790777

TEST027a
  EQUIV_NEXT generates all partitions of a set.

  Rank//element:

       1   2   3   4  

   1   1   1   1   1  
   2   1   1   1   2  
   3   1   1   2   1  
   4   1   1   2   2  
   5   1   1   2   3  
   6   1   2   1   1  
   7   1   2   1   2  
   8   1   2   1   3  
   9   1   2   2   1  
  10   1   2   2   2  
  11   1   2   2   3  
  12   1   2   3   1  
  13   1   2   3   2  
  14   1   2   3   3  
  15   1   2   3   4  

TEST028a
  EQUIV_NEXT2 generates all partitions of a set.

  Rank//element:

       1   2   3   4  

   1   1   1   1   1  
   2   1   1   1   2  
   3   1   1   2   1  
   4   1   1   2   2  
   5   1   1   2   3  
   6   1   2   1   1  
   7   1   2   1   2  
   8   1   2   1   3  
   9   1   2   2   1  
  10   1   2   2   2  
  11   1   2   2   3  
  12   1   2   3   1  
  13   1   2   3   2  
  14   1   2   3   3  
  15   1   2   3   4  

TEST029a
  EQUIV_RANDOM selects a random set partition.

  The partition:

  Set    Size  Elements
     1     1 ::    1  
     2     3 ::    2     3     4  

  The partition:

  Set    Size  Elements
     1     1 ::    4  
     2     1 ::    2  
     3     1 ::    3  
     4     1 ::    1  

  The partition:

  Set    Size  Elements
     1     3 ::    1     2     3  
     2     1 ::    4  

  The partition:

  Set    Size  Elements
     1     3 ::    2     3     4  
     2     1 ::    1  

  The partition:

  Set    Size  Elements
     1     1 ::    2  
     2     1 ::    4  
     3     2 ::    1     3  

  Now repeat, but print using EQUIV_PRINT2


  The partition:

(0)(1,2,3)

  The partition:

(3)(1)(2)(0)

  The partition:

(0,1,2)(3)

  The partition:

(1,2,3)(0)

  The partition:

(1)(3)(0,2)

TEST0295
  EULER gets rows of the Euler triangle.

      1  
      1        0  
      1        1        0  
      1        4        1        0  
      1       11       11        1        0  
      1       26       66       26        1        0  
      1       57      302      302       57        1        0  
      1      120     1191     2416     1191      120        1        0  
      1      247     4293    15619    15619     4293      247        1        0  
      1      502    14608    88234   156190    88234    14608      502        1        0  

TEST0304
  FROBENIUS_NUMBER_ORDER2 computes Frobenius numbers of order 2.
  FROBENIUS_NUMBER_ORDER2_VALUES returns some exact values.

        C1        C1   exact F  comput F

         2         5         3         3
         3        17        31        31
         4        19        23        53
         5        13        47        47
        12        11       109       109
        99       100      9701      9701

TEST0305:
  R8_GAMMA_LOG evaluates the logarithm of the Gamma function.
  GAMMA_LOG_VALUES returns some exact values.

     X       Exact F       GAMMA_LOG(X)

     0.2     1.52406     1.52406
     0.4    0.796678    0.796678
     0.6    0.398234    0.398234
     0.8     0.15206     0.15206
       1           0           0
     1.1  -0.0498725  -0.0498724
     1.2  -0.0853741  -0.0853741
     1.3   -0.108175   -0.108175
     1.4   -0.119613   -0.119613
     1.5   -0.120782   -0.120782
     1.6   -0.112592   -0.112592
     1.7  -0.0958077  -0.0958077
     1.8  -0.0710839  -0.0710839
     1.9  -0.0389843  -0.0389843
       2           0           0
      10     12.8018     12.8018
      20     39.3399     39.3399
      30      71.257      71.257

TEST031
  GRAY_NEXT returns the index of the single item
  to be changed in order to get the next Gray code.

   K  Switch  Gray Code

   0       0  0000
   1       1  1000
   2       2  1100
   3      -1  0100
   4       3  0110
   5       1  1110
   6      -2  1010
   7      -1  0010
   8       4  0011
   9       1  1011
  10       2  1111
  11      -1  0111
  12      -3  0101
  13       1  1101
  14      -2  1001
  15      -1  0001

TEST032
  GRAY_RANK ranks a Gray code;
  GRAY_UNRANK unranks a Gray code.

    R  =                        RANK
    G  =            GRAY_UNRANK(RANK)
    R2 =  GRAY_RANK(GRAY_UNRANK(RANK))

    R    G    R2

        0          0          0
        1          1          1
        2          3          2
        3          2          3
        4          6          4
        5          7          5
        6          5          6
        7          4          7
        8         12          8
        9         13          9
       10         15         10
       11         14         11
       12         10         12
       13         11         13
       14          9         14
       15          8         15
       16         24         16
       17         25         17
       18         27         18
       19         26         19
       20         30         20
       21         31         21
       22         29         22
       23         28         23
       24         20         24

TEST0321
  GRAY_RANK2 ranks a Gray code;
  GRAY_UNRANK2 unranks a Gray code.

    R  =                          RANK
    G  =             GRAY_UNRANK2(RANK)
    R2 =  GRAY_RANK2(GRAY_UNRANK2(RANK))

    R    G    R2

        0          0          0
        1          1          1
        2          3          2
        3          2          3
        4          6          4
        5          7          5
        6          5          6
        7          4          7
        8         12          8
        9         13          9
       10         15         10
       11         14         11
       12         10         12
       13         11         13
       14          9         14
       15          8         15
       16         24         16
       17         25         17
       18         27         18
       19         26         19
       20         30         20
       21         31         21
       22         29         22
       23         28         23
       24         20         24

TEST0322
  I4_BCLR sets a given bit to 0.

  Working on I4 = 101

       Pos     Digit       I4_BCLR

         0         0  100
         1         0  101
         2         0  97
         3         0  101
         4         0  101
         5         0  69
         6         0  37
         7         0  101
         8         0  101
         9         0  101
        10         0  101
        11         0  101
        12         0  101
        13         0  101
        14         0  101
        15         0  101
        16         0  101
        17         0  101
        18         0  101
        19         0  101
        20         0  101
        21         0  101
        22         0  101
        23         0  101
        24         0  101
        25         1  101
        26         1  101
        27         0  101
        28         0  101
        29         1  101
        30         0  101
        31         1  101

  Working on I4 = -31

       Pos     Digit       I4_BCLR

         0         1  -32
         1         1  -31
         2         1  -31
         3         1  -31
         4         1  -31
         5         1  -63
         6         1  -95
         7         1  -159
         8         1  -287
         9         1  -543
        10         1  -1055
        11         1  -2079
        12         1  -4127
        13         1  -8223
        14         1  -16415
        15         1  -32799
        16         1  -65567
        17         1  -131103
        18         1  -262175
        19         1  -524319
        20         1  -1048607
        21         1  -2097183
        22         1  -4194335
        23         1  -8388639
        24         1  -16777247
        25         1  -33554463
        26         1  -67108895
        27         0  -134217759
        28         0  -268435487
        29         0  -536870943
        30         0  -1073741855
        31         1  2147483617

TEST03225
  I4_BSET sets a given bit to 0.

  Working on I4 = 101

       Pos     Digit       I4_BSET

         0         0  101
         1         0  103
         2         0  101
         3         0  109
         4         0  117
         5         0  101
         6         0  101
         7         0  229
         8         0  357
         9         0  613
        10         0  1125
        11         0  2149
        12         0  4197
        13         0  8293
        14         0  16485
        15         0  32869
        16         0  65637
        17         0  131173
        18         0  262245
        19         0  524389
        20         0  1048677
        21         0  2097253
        22         0  4194405
        23         0  8388709
        24         0  16777317
        25         1  33554533
        26         1  67108965
        27         0  134217829
        28         0  268435557
        29         1  536871013
        30         0  1073741925
        31         1  -2147483547

  Working on I4 = -31

       Pos     Digit       I4_BSET

         0         1  -31
         1         1  -29
         2         1  -27
         3         1  -23
         4         1  -15
         5         1  -31
         6         1  -31
         7         1  -31
         8         1  -31
         9         1  -31
        10         1  -31
        11         1  -31
        12         1  -31
        13         1  -31
        14         1  -31
        15         1  -31
        16         1  -31
        17         1  -31
        18         1  -31
        19         1  -31
        20         1  -31
        21         1  -31
        22         1  -31
        23         1  -31
        24         1  -31
        25         1  -31
        26         1  -31
        27         0  -31
        28         0  -31
        29         0  -31
        30         0  -31
        31         1  -31

TEST0323
  I4_BTEST reports whether a given bit is 0 or 1.

  Analyze the integer I4 = 101

       Pos     Digit  I4_BTEST

         0         0  1
         1         0  0
         2         0  1
         3         0  0
         4         0  0
         5         0  1
         6         0  1
         7         0  0
         8         0  0
         9         0  0
        10         0  0
        11         0  0
        12         0  0
        13         0  0
        14         0  0
        15         0  0
        16         0  0
        17         0  0
        18         0  0
        19         0  0
        20         0  0
        21         0  0
        22         0  0
        23         0  0
        24         0  0
        25         1  0
        26         1  0
        27         0  0
        28         0  0
        29         1  0
        30         0  0
        31         1  0

  Analyze the integer I4 = -31

       Pos     Digit  I4_BTEST

         0         1  1
         1         1  0
         2         1  0
         3         1  0
         4         1  0
         5         1  1
         6         1  1
         7         1  1
         8         1  1
         9         1  1
        10         1  1
        11         1  1
        12         1  1
        13         1  1
        14         1  1
        15         1  1
        16         1  1
        17         1  1
        18         1  1
        19         1  1
        20         1  1
        21         1  1
        22         1  1
        23         1  1
        24         1  1
        25         1  1
        26         1  1
        27         0  1
        28         0  1
        29         0  1
        30         0  1
        31         1  1

TEST0324
  I4_FACTOR factors an integer,

  The integer is 2516

  Prime representation:

  I  FACTOR(I)  POWER(I)

       1       2       2
       2      17       1
       3      37       1

TEST0325
  I4_GCD computes the greatest common divisor
  of two integers.

     I     J    I4_GCD(I,J)

  -1    15     1
  12     9     3
   3     1     1
   0     2     2
  -5    10     5
  -4     7     1
   3    12     3
  11     1     1
  13     6     1
  -4     1     1
  13    13    13
  -3     1     1
   0    14    14
  -3     6     3
  12     5     1

TEST0327
  I4_LOG_10: whole part of log base 10,

     X I4_LOG_10

     0       0
     1       0
     2       0
     3       0
     9       0
    10       1
    11       1
    99       1
   100       2
   101       2
   999       2
  1000       3
  1001       3
    -1       0
    -2       0
    -3       0
    -9       0
   -10       1
   -11       1
   -99       1
  -101       2

TEST058
  I4_PARTITION_CONJ conjugates an integer partition.

  Original partition:

  14 = 1 * 2 + 1 * 5 + 3 * 1 + 1 * 4

  Conjugate partition:

  14 = 1 * 6 + 1 * 3 + 2 * 2 + 1 * 1

TEST059
  I4_PARTITION_NEXT generates partitions of an integer.
  Here N = 7

  7 = 1 * 7
  7 = 1 * 6 + 1 * 1
  7 = 1 * 5 + 1 * 2
  7 = 1 * 5 + 2 * 1
  7 = 1 * 4 + 1 * 3
  7 = 1 * 4 + 1 * 2 + 1 * 1
  7 = 1 * 4 + 3 * 1
  7 = 2 * 3 + 1 * 1
  7 = 1 * 3 + 2 * 2
  7 = 1 * 3 + 1 * 2 + 2 * 1
  7 = 1 * 3 + 4 * 1
  7 = 3 * 2 + 1 * 1
  7 = 2 * 2 + 3 * 1
  7 = 1 * 2 + 5 * 1
  7 = 7 * 1

TEST060
  I4_PARTITION_NEXT2 produces partitions of an integer.

  7 = 1 * 7
  7 = 1 * 6 + 1 * 1
  7 = 1 * 5 + 1 * 2
  7 = 1 * 5 + 2 * 1
  7 = 1 * 4 + 1 * 3
  7 = 1 * 4 + 1 * 2 + 1 * 1
  7 = 1 * 4 + 3 * 1
  7 = 2 * 3 + 1 * 1
  7 = 1 * 3 + 2 * 2
  7 = 1 * 3 + 1 * 2 + 2 * 1
  7 = 1 * 3 + 4 * 1
  7 = 3 * 2 + 1 * 1
  7 = 2 * 2 + 3 * 1
  7 = 1 * 2 + 5 * 1
  7 = 7 * 1

TEST061
  I4_PARTITION_COUNT counts partitions of an integer.
  I4_PARTITION_COUNT_VALUES returns some exact values.

   N     Exact     Count

   0           1           1
   1           1           1
   2           2           2
   3           3           3
   4           5           5
   5           7           7
   6          11          11
   7          15          15
   8          22          22
   9          30          30
  10          42          42
  11          56          56
  12          77          77
  13         101         101
  14         135         135
  15         176         176
  16         231         231
  17         297         297
  18         385         385
  19         490         490
  20         627         627

TEST0615
  I4_PARTITION_COUNT2 counts partitions of an integer.
  I4_PARTITION_COUNT_VALUES returns some exact values.

   N     Exact     Count

     0           1                   1
     1           1                   1
     2           2                   2
     3           3                   3
     4           5                   5
     5           7                   7
     6          11                  11
     7          15                  15
     8          22                  22
     9          30                  30
    10          42                  42
    11          56                  56
    12          77                  77
    13         101                 101
    14         135                 135
    15         176                 176
    16         231                 231
    17         297                 297
    18         385                 385
    19         490                 490
    20         627                 627

TEST062
  I4_PARTITION_RANDOM generates a random partition.
  I4_PARTITION_COUNT2 sets up a necessary table.


  The number of partitions of N.

     N    Number of partitions

     1       1
     2       1
     3       2
     4       3
     5       5
     6       7
     7      11
     8      15

  8 = 5 * 1 + 1 * 3
  8 = 2 * 1 + 1 * 6
  8 = 4 * 1 + 2 * 2
  8 = 4 * 1 + 1 * 4
  8 = 1 * 1 + 1 * 2 + 1 * 5

TEST06225
  I4_PARTITIONS_NEXT produces the next
  nondecreasing partitions of an integer, and
  if necessary, increments the integer to keep on going.

   I Sum    Partition

   0   0     0 0 0
   1   1     1 0 0
   2   2     2 0 0
   3   2     1 1 0
   4   3     3 0 0
   5   3     2 1 0
   6   3     1 1 1
   7   4     4 0 0
   8   4     3 1 0
   9   4     2 2 0
  10   4     2 1 1
  11   5     5 0 0
  12   5     4 1 0
  13   5     3 2 0
  14   5     3 1 1
  15   5     2 2 1

  You can start from any legal partition.
  Here, we restart at ( 2, 1, 0 ).

   I Sum    Partition

   0   3     2 1 0
   1   3     1 1 1
   2   4     4 0 0
   3   4     3 1 0
   4   4     2 2 0
   5   4     2 1 1
   6   5     5 0 0
   7   5     4 1 0
   8   5     3 2 0
   9   5     3 1 1
  10   5     2 2 1
  11   6     6 0 0
  12   6     5 1 0
  13   6     4 2 0
  14   6     3 3 0
  15   6     4 1 1

TEST033
  I4_SQRT computes the square root of an integer.

       N  Sqrt(N) Remainder

       -5          2          1
       -4          2          0
       -3          1          2
       -2          1          1
       -1          1          0
        0          0          0
        1          1          0
        2          1          1
        3          1          2
        4          2          0
        5          2          1
        6          2          2
        7          2          3
        8          2          4
        9          3          0
       10          3          1
       11          3          2
       12          3          3
       13          3          4
       14          3          5
       15          3          6
       16          4          0
       17          4          1
       18          4          2
       19          4          3
       20          4          4

TEST034
  I4_SQRT_CF computes the continued fraction form
  of the square root of an integer.

   N  Period  Whole  Repeating Part

    1      0      1  
    2      1      1      2  
    3      2      1      1      2  
    4      0      2  
    5      1      2      4  
    6      2      2      2      4  
    7      4      2      1      1      1      4  
    8      2      2      1      4  
    9      0      3  
   10      1      3      6  
   11      2      3      3      6  
   12      2      3      2      6  
   13      5      3      1      1      1      1      6  
   14      4      3      1      2      1      6  
   15      2      3      1      6  
   16      0      4  
   17      1      4      8  
   18      2      4      4      8  
   19      6      4      2      1      3      1      2      8  
   20      2      4      2      8  

TEST0625
  I4_TO_BVEC converts an integer to a 
    signed binary vector;
  BVEC_TO_I4 converts a signed binary vector
    to an integer;

  I --> BVEC  -->  I

 -3  1111111101   -3
 -2  1111111110   -2
 -1  1111111111   -1
  0  0000000000    0
  1  0000000001    1
  2  0000000010    2
  3  0000000011    3
  4  0000000100    4
  5  0000000101    5
  6  0000000110    6
  7  0000000111    7
  8  0000001000    8
  9  0000001001    9
 10  0000001010   10

TEST035
  I4_TO_CHINESE computes the Chinese Remainder
    representation of an integer.
  CHINESE_TO_I4 computes an integer with the given
    Chinese Remainder representation.

  The moduli:

       1         3
       2         4
       3         5
       4         7

  The number being analyzed is 37

  The remainders:

       1         1
       2         1
       3         2
       4         2

  The reconstructed number is 37

  The remainders of the reconstructed number are:

       1         1
       2         1
       3         2
       4         2

TEST0627
  I4_TO_I4POLY converts an integer to a polynomial
    in a given base;
  I4POLY_TO_I4 evaluates an integer polynomial
    at a given point;

       I    BASE  DEGREE  Coefficients

       1       2       0       1  
       6       2       2       0       1       1  
      23       2       4       1       1       1       0       1  
      23       3       2       2       1       2  
      23       4       2       3       1       1  
      23       5       1       3       4  
      23       6       1       5       3  
      23      23       1       0       1  
      23      24       0      23  

  Now let I4_TO_I4POLY convert I to a polynomial,
  use I4POLY_TO_I4 to evaluate it, and compare.

       I    I2

       1       1
       6       6
      23      23
      23      23
      23      23
      23      23
      23      23
      23      23
      23      23

TEST0364
  I4_TO_VAN_DER_CORPUT computes the elements
    of a van der Corput sequence.

  I4_TO_I4POLY converts an integer to an integer
    polynomial in some base, and can be used to mimic
    the van der Corput calculation.


  BASE = 2

       1             0.5             0.5
       2            0.25            0.25
       3            0.75            0.75
       4           0.125           0.125
       5           0.625           0.625
       6           0.375           0.375
       7           0.875           0.875
       8          0.0625          0.0625
       9          0.5625          0.5625
      10          0.3125          0.3125

  BASE = 3

       1        0.333333        0.333333
       2        0.666667        0.666667
       3        0.111111        0.111111
       4        0.444444        0.444444
       5        0.777778        0.777778
       6        0.222222        0.222222
       7        0.555556        0.555556
       8        0.888889        0.888889
       9        0.037037        0.037037
      10         0.37037         0.37037

  BASE = 5

       1             0.2             0.2
       2             0.4             0.4
       3             0.6             0.6
       4             0.8             0.8
       5            0.04            0.04
       6            0.24            0.24
       7            0.44            0.44
       8            0.64            0.64
       9            0.84            0.84
      10            0.08            0.08

TEST036
  I4_TO_VAN_DER_CORPUT computes the elements 
  of a van der Corput sequence.
  The sequence depends on the prime number used
  as a base.

Base:          2           3           5           7          11  

   1         0.5    0.333333         0.2    0.142857   0.0909091  
   2        0.25    0.666667         0.4    0.285714    0.181818  
   3        0.75    0.111111         0.6    0.428571    0.272727  
   4       0.125    0.444444         0.8    0.571429    0.363636  
   5       0.625    0.777778        0.04    0.714286    0.454545  
   6       0.375    0.222222        0.24    0.857143    0.545455  
   7       0.875    0.555556        0.44   0.0204082    0.636364  
   8      0.0625    0.888889        0.64    0.163265    0.727273  
   9      0.5625    0.037037        0.84    0.306122    0.818182  
  10      0.3125     0.37037        0.08     0.44898    0.909091  

TEST037
  I4MAT_01_ROWCOLSUM constructs a 01 matrix with
  given row and column sums.

  The rowsum vector:

       1         3
       2         2
       3         2
       4         1
       5         1

  The columnsum vector: 

       1         2
       2         2
       3         2
       4         2
       5         1

  The rowcolsum matrix:

  Col:          1             2             3             4             5       
  Row
  ---
    1       1       0       1       0       1  
    2       1       0       0       1       0  
    3       0       1       0       1       0  
    4       0       1       0       0       0  
    5       0       0       1       0       0  

SUBSET_PRB:
  TEST038 is imperfect because I4MAT_ROWCOLSUM2 is not ready.

TEST038
  I4MAT_01_ROWCOLSUM2 constructs a 01 matrix with
  given row and column sums.

  The rowsum vector:

       1         2
       2         1
       3         3
       4         1
       5         2

  The columnsum vector: 

       1         2
       2         1
       3         2
       4         2
       5         2

TEST038
  Cancel test!  The routine is not ready!

TEST039
  I4MAT_01_ROWCOLSUM constructs a 01 matrix with
  given row and column sums.

  The rowsum vector R:

       1        14
       2        13
       3        14
       4        10
       5        12
       6         2
       7        10
       8         1
       9        10
      10        11
      11         6
      12         2
      13        17

  The columnsum vector C: 

       1         4
       2         4
       3        11
       4        10
       5        10
       6         8
       7         9
       8        10
       9         8
      10         9
      11         3
      12        10
      13         4
      14         7
      15         9
      16         3
      17         3

  The rowcolsum matrix:

  Col:          1             2             3             4             5             6             7             8             9            10       
  Row
  ---
    1       0       1       1       1       1       1       1       1       1       1  
    2       1       0       1       1       1       0       1       1       1       1  
    3       1       0       1       1       1       1       1       1       0       1  
    4       0       0       1       0       1       1       1       1       1       1  
    5       1       1       1       1       1       1       1       1       1       1  
    6       0       0       0       1       1       0       0       0       0       0  
    7       0       0       1       1       0       1       1       1       1       1  
    8       0       0       0       1       0       0       0       0       0       0  
    9       0       0       1       1       0       1       1       1       1       1  
   10       0       1       1       1       1       1       1       1       1       0  
   11       0       0       1       0       1       0       0       1       0       1  
   12       0       0       1       0       1       0       0       0       0       0  
   13       1       1       1       1       1       1       1       1       1       1  

  Col:         11            12            13            14            15            16            17       
  Row
  ---
    1       1       1       1       0       1       1       0  
    2       0       1       1       1       1       0       1  
    3       0       1       1       1       1       1       1  
    4       0       1       0       1       1       0       0  
    5       0       1       0       1       0       0       0  
    6       0       0       0       0       0       0       0  
    7       0       1       0       1       1       0       0  
    8       0       0       0       0       0       0       0  
    9       0       1       0       1       1       0       0  
   10       0       1       0       1       1       0       0  
   11       0       1       0       0       1       0       0  
   12       0       0       0       0       0       0       0  
   13       2       1       1       0       1       1       1  

  Computed row sums

       1        14
       2        13
       3        14
       4        10
       5        12
       6         2
       7        10
       8         1
       9        10
      10        11
      11         6
      12         2
      13        17

  Computed column sums:

       1         4
       2         4
       3        11
       4        10
       5        10
       6         8
       7         9
       8        10
       9         8
      10         9
      11         3
      12        10
      13         4
      14         7
      15         9
      16         3
      17         3

TEST040
  I4MAT_U1_INVERSE inverts a unit upper triangular matrix.

  The input matrix:

  Col:          1             2             3             4             5             6       
  Row
  ---
    1       1       1       0       0       0      75  
    2       0       1       0       0       0       0  
    3       0       0       1       1       0       0  
    4       0       0       0       1       0       0  
    5       0       0       0       0       1       1  
    6       0       0       0       0       0       1  

  The inverse matrix:

  Col:          1             2             3             4             5             6       
  Row
  ---
    1       1      -1       0       0       0     -75  
    2       0       1       0       0       0       0  
    3       0       0       1      -1       0       0  
    4       0       0       0       1       0       0  
    5       0       0       0       0       1      -1  
    6       0       0       0       0       0       1  

TEST041
  I4MAT_PERM reorders an integer matrix in place.
  The rows and columns use the same permutation.

  The input matrix:

  Col:          1             2             3             4             5             6             7             8             9       
  Row
  ---
    1      11      12      13      14      15      16      17      18      19  
    2      21      22      23      24      25      26      27      28      29  
    3      31      32      33      34      35      36      37      38      39  
    4      41      42      43      44      45      46      47      48      49  
    5      51      52      53      54      55      56      57      58      59  
    6      61      62      63      64      65      66      67      68      69  
    7      71      72      73      74      75      76      77      78      79  
    8      81      82      83      84      85      86      87      88      89  
    9      91      92      93      94      95      96      97      98      99  

  The row and column permutation:

     0   1   2   3   4   5   6   7   8
     2   3   9   6   7   8   5   4   1

  The permuted matrix:

  Col:          1             2             3             4             5             6             7             8             9       
  Row
  ---
    1      99      91      92      98      97      94      95      96      93  
    2      19      11      12      18      17      14      15      16      13  
    3      29      21      22      28      27      24      25      26      23  
    4      89      81      82      88      87      84      85      86      83  
    5      79      71      72      78      77      74      75      76      73  
    6      49      41      42      48      47      44      45      46      43  
    7      59      51      52      58      57      54      55      56      53  
    8      69      61      62      68      67      64      65      66      63  
    9      39      31      32      38      37      34      35      36      33  

TEST042
  I4MAT_PERM2 reorders an integer matrix in place.
  Rows and columns use different permutations.

  The input matrix:

  Col:          1             2             3             4             5             6             7       
  Row
  ---
    1      11      12      13      14      15      16      17  
    2      21      22      23      24      25      26      27  
    3      31      32      33      34      35      36      37  
    4      41      42      43      44      45      46      47  
    5      51      52      53      54      55      56      57  
    6      61      62      63      64      65      66      67  
    7      71      72      73      74      75      76      77  
    8      81      82      83      84      85      86      87  
    9      91      92      93      94      95      96      97  

  The row permutation:

     0   1   2   3   4   5   6   7   8
     2   3   9   6   7   8   5   4   1

  The column permutation:

     0   1   2   3   4   5   6
     3   4   5   6   7   1   2

  The permuted matrix:

  Col:          1             2             3             4             5             6             7       
  Row
  ---
    1      96      97      91      92      93      94      95  
    2      16      17      11      12      13      14      15  
    3      26      27      21      22      23      24      25  
    4      86      87      81      82      83      84      85  
    5      76      77      71      72      73      74      75  
    6      46      47      41      42      43      44      45  
    7      56      57      51      52      53      54      55  
    8      66      67      61      62      63      64      65  
    9      36      37      31      32      33      34      35  

TEST043
  INDEX_BOX_NEXT_2D produces IJ indices that
  lie on the surface of a box in 2D.

  The box has logical dimensions:
  5    3

   #    I   J

  1    1    1
  2    1    2
  3    1    3
  4    2    1
  5    2    3
  6    3    1
  7    3    3
  8    4    1
  9    4    3
 10    5    1
 11    5    2
 12    5    3

TEST044
  INDEX_BOX_NEXT_3D produces IJK indices that
  lie on the surface of a box.

  The box has logical dimensions:
  5    3    4

   #    I   J   K

  1    1    1    1
  2    1    1    2
  3    1    1    3
  4    1    1    4
  5    1    2    1
  6    1    2    2
  7    1    2    3
  8    1    2    4
  9    1    3    1
 10    1    3    2
 11    1    3    3
 12    1    3    4
 13    2    1    1
 14    2    1    2
 15    2    1    3
 16    2    1    4
 17    2    2    1
 18    2    2    4
 19    2    3    1
 20    2    3    2
 21    2    3    3
 22    2    3    4
 23    3    1    1
 24    3    1    2
 25    3    1    3
 26    3    1    4
 27    3    2    1
 28    3    2    4
 29    3    3    1
 30    3    3    2
 31    3    3    3
 32    3    3    4
 33    4    1    1
 34    4    1    2
 35    4    1    3
 36    4    1    4
 37    4    2    1
 38    4    2    4
 39    4    3    1
 40    4    3    2
 41    4    3    3
 42    4    3    4
 43    5    1    1
 44    5    1    2
 45    5    1    3
 46    5    1    4
 47    5    2    1
 48    5    2    2
 49    5    2    3
 50    5    2    4
 51    5    3    1
 52    5    3    2
 53    5    3    3
 54    5    3    4

TEST045
 INDEX_BOX2_NEXT_2D produces IJ indices that
  lie on the surface of a box2 in 2D.

  The box has half-widths:
  4    3

  and has center cell:
 10   20

   #    I   J

  1    6   17
  2    6   18
  3    6   19
  4    6   20
  5    6   21
  6    6   22
  7    6   23
  8    7   17
  9    7   23
 10    8   17
 11    8   23
 12    9   17
 13    9   23
 14   10   17
 15   10   23
 16   11   17
 17   11   23
 18   12   17
 19   12   23
 20   13   17
 21   13   23
 22   14   17
 23   14   18
 24   14   19
 25   14   20
 26   14   21
 27   14   22
 28   14   23

TEST046
  INDEX_BOX2_NEXT_3D produces IJK indices that
  lie on the surface of a box.

  The box has half widths:
  5    3    4

  and central cell:
 10   20   30

  We will only print a PORTION of the data!

   #    I   J   K

  1    5   17   26
  2    5   17   27
  3    5   17   28
  4    5   17   29
  5    5   17   30
  6    5   17   31
  7    5   17   32
  8    5   17   33
  9    5   17   34
 10    5   18   26
370   15   23   26
371   15   23   27
372   15   23   28
373   15   23   29
374   15   23   30
375   15   23   31
376   15   23   32
377   15   23   33
378   15   23   34

TEST047
  TRIANG relabels elements for a partial ordering,
  I4MAT_PERM2 reorders an integer matrix in place.

  The input matrix:

  Col:          1             2             3             4             5             6             7             8             9            10       
  Row
  ---
    1       1       0       0       0       0       0       0       0       0       0  
    2       0       1       0       1       0       1       0       1       0       0  
    3       1       0       1       1       0       0       0       0       0       0  
    4       0       0       0       1       0       0       0       0       0       0  
    5       1       1       1       1       1       1       1       1       0       1  
    6       0       0       0       1       0       1       0       1       0       0  
    7       1       0       1       1       0       1       1       1       0       1  
    8       0       0       0       1       0       0       0       1       0       0  
    9       0       0       0       0       0       0       0       0       0       0  
   10       1       0       1       1       0       0       0       1       0       1  

  The new ordering:

     0   1   2   3   4   5   6   7   8   9
     5   6   4   9   1   7   2   8  10   3

  The reordered matrix:

  Col:          1             2             3             4             5             6             7             8             9            10       
  Row
  ---
    1       1       1       1       1       1       1       1       1       1       0  
    2       0       1       1       1       1       0       1       1       1       0  
    3       0       0       1       1       1       0       0       1       1       0  
    4       0       0       0       1       1       0       0       0       1       0  
    5       0       0       0       0       1       0       0       0       0       0  
    6       0       0       0       0       0       1       1       1       1       0  
    7       0       0       0       0       0       0       1       1       1       0  
    8       0       0       0       0       0       0       0       1       1       0  
    9       0       0       0       0       0       0       0       0       1       0  
   10       0       0       0       0       0       0       0       0       0       0  

TEST048
  INDEX_NEXT0 generates all indices of an
  array of given shape, with
  lower limit 1 and given upper limit.

  Number of index entries = 3
  Coordinate maximum HI =   3

  Index arrays:

   1     1     1  
   2     1     1  
   3     1     1  
   1     2     1  
   2     2     1  
   3     2     1  
   1     3     1  
   2     3     1  
   3     3     1  
   1     1     2  
   2     1     2  
   3     1     2  
   1     2     2  
   2     2     2  
   3     2     2  
   1     3     2  
   2     3     2  
   3     3     2  
   1     1     3  
   2     1     3  
   3     1     3  
   1     2     3  
   2     2     3  
   3     2     3  
   1     3     3  
   2     3     3  
   3     3     3  

TEST049
  INDEX_NEXT1 generates all indices of an
  array of given shape, with
  lower limit 1 and given upper limits.

  Number of index entries = 3

  Coordinate maximum indices:

       1         4
       2         2
       3         3

  Index arrays:

   1     1     1  
   2     1     1  
   3     1     1  
   4     1     1  
   1     2     1  
   2     2     1  
   3     2     1  
   4     2     1  
   1     1     2  
   2     1     2  
   3     1     2  
   4     1     2  
   1     2     2  
   2     2     2  
   3     2     2  
   4     2     2  
   1     1     3  
   2     1     3  
   3     1     3  
   4     1     3  
   1     2     3  
   2     2     3  
   3     2     3  
   4     2     3  

TEST050
  INDEX_NEXT2 generates all indices of an
  array of given shape with given
  lower and upper limits.

  Number of index entries = 3

  Coordinate, Maximum Index

       1        10        11
       2        -5        -3
       3         0         1

Index arrays:

  10    -5     0  
  11    -5     0  
  10    -4     0  
  11    -4     0  
  10    -3     0  
  11    -3     0  
  10    -5     1  
  11    -5     1  
  10    -4     1  
  11    -4     1  
  10    -3     1  
  11    -3     1  

TEST051
  INDEX_RANK0 ranks an index with
  lower limit 1 and given upper limit.

  Number of index entries = 3

  Coordinate maximum Index = 3


  The index array:

       1         3
       2         1
       3         2

  The rank of this object is 12

TEST052
  INDEX_RANK1 ranks an index with
  lower limit 1 and given upper limits.

  Number of index entries = 3

  Coordinate, Maximum Index

         1           4
         2           2
         3           3

  The index array:

       1         4
       2         1
       3         2

  The rank of this object is 12

TEST053
  INDEX_RANK2 ranks an index with given
  lower and upper limits.

  Number of index entries = 3

  Coordinate, Minimum index, Maximum Index

         1           1           2
         2          10          11
         3           4           6

  The index array:

       1         1
       2        11
       3         5

  The rank of this object is 7

TEST054
  INDEX_UNRANK0 unranks a multi-index.

  The multi-index has dimension 3

  The upper limit is HI = 3

  Rank, Multi-Index:

  1       1       1       1  
  2       2       1       1  
  3       3       1       1  
  4       1       2       1  
  5       2       2       1  
  6       3       2       1  
  7       1       3       1  
  8       2       3       1  
  9       3       3       1  
 10       1       1       2  
 11       2       1       2  
 12       3       1       2  
 13       1       2       2  
 14       2       2       2  
 15       3       2       2  
 16       1       3       2  
 17       2       3       2  
 18       3       3       2  
 19       1       1       3  
 20       2       1       3  
 21       3       1       3  
 22       1       2       3  
 23       2       2       3  
 24       3       2       3  
 25       1       3       3  
 26       2       3       3  
 27       3       3       3  

TEST055
  INDEX_UNRANK1 unranks a multi-index.

  The multi-index has dimension 3

  The upper limits:

       1         4
       2         2
       3         3

  Rank, Multi-Index:

  1       1       1       1  
  2       2       1       1  
  3       3       1       1  
  4       4       1       1  
  5       1       2       1  
  6       2       2       1  
  7       3       2       1  
  8       4       2       1  
  9       1       1       2  
 10       2       1       2  
 11       3       1       2  
 12       4       1       2  
 13       1       2       2  
 14       2       2       2  
 15       3       2       2  
 16       4       2       2  
 17       1       1       3  
 18       2       1       3  
 19       3       1       3  
 20       4       1       3  
 21       1       2       3  
 22       2       2       3  
 23       3       2       3  
 24       4       2       3  

TEST056
  INDEX_UNRANK2 unranks a multi-index.

  The multi-index has dimension 3

  The lower and upper limits are:

         0           1           2
         1          10          11
         2           4           6

  Rank, Multi-Index:

  7       1      11       5  

TEST057
  PERM_INS computes the inversion sequence.
  INS_PERM recovers the permutation.


  The permutation:

       1         3
       2         5
       3         1
       4         4
       5         2

  The inversion sequence:

       1         0
       2         0
       3         2
       4         1
       5         3

  The recovered permutation:

       1         3
       2         5
       3         1
       4         4
       5         2

TEST063
  INVOLUTE_ENUM counts involutions;


  N    # of involutions

         0           1
         1           1
         2           2
         3           4
         4          10
         5          26
         6          76
         7         232
         8         764
         9        2620
        10        9496

TEST064
  I4POLY converts between power sum, factorial
  and Taylor forms, and can evaluate a polynomial


  All calls have input A as follows:

       1         0
       2         0
       3         0
       4         0
       5         0
       6         1

  Option IOPT = -3

  Output array:

       1         0
       2        24
       3       -50
       4        35
       5       -10
       6         1

  Option IOPT = -2

  Output array:

       1         0
       2         1
       3        15
       4        25
       5        10
       6         1

  Option IOPT = -1
  X0 = 2
  Value = 0

  Option IOPT = 0
  X0 = 2
  Value = 32

  Option IOPT = 6
  X0 = 2

  Output array:

       1        32
       2        80
       3        80
       4        40
       5        10
       6         1

  Option IOPT = 6
  X0 = -2

  Output array:

       1       -32
       2        80
       3       -80
       4        40
       5       -10
       6         1

TEST065
  I4POLY_CYCLO computes cyclotomic polynomials.

  N = 0


  The cyclotomic polynomial:

p(x) =  1

  N = 1


  The cyclotomic polynomial:

p(x) =  1 * x
       -1

  N = 2


  The cyclotomic polynomial:

p(x) =  1 * x
       +1

  N = 3


  The cyclotomic polynomial:

p(x) =  1 * x^2
       +1 * x
       +1

  N = 4


  The cyclotomic polynomial:

p(x) =  1 * x^2
       +1

  N = 5


  The cyclotomic polynomial:

p(x) =  1 * x^4
       +1 * x^3
       +1 * x^2
       +1 * x
       +1

  N = 6


  The cyclotomic polynomial:

p(x) =  1 * x^2
       -1 * x
       +1

  N = 7


  The cyclotomic polynomial:

p(x) =  1 * x^6
       +1 * x^5
       +1 * x^4
       +1 * x^3
       +1 * x^2
       +1 * x
       +1

  N = 8


  The cyclotomic polynomial:

p(x) =  1 * x^4
       +1

  N = 9


  The cyclotomic polynomial:

p(x) =  1 * x^6
       +1 * x^3
       +1

  N = 10


  The cyclotomic polynomial:

p(x) =  1 * x^4
       -1 * x^3
       +1 * x^2
       -1 * x
       +1

TEST0655
  I4POLY_DIF computes derivatives of an I4POLY.


  The polynomial A:

p(x) =  1 * x^3
       +2 * x^2
       -5 * x
       -6

  Differentiate A 1 times.

  The derivative, B:

p(x) =  3 * x^2
       +4 * x
       -5

  The polynomial A:

p(x) =  1 * x^4
       +3 * x^3
       +2 * x^2
       +5 * x
       -2

  Differentiate A 3 times.

  The derivative, B:

p(x) =  24 * x
       +18

TEST066
  I4POLY_DIV computes the quotient and
  remainder for polynomial division.


  The polynomial to be divided, A:

p(x) =  1 * x^3
       +2 * x^2
       -5 * x
       -6

  The divisor polynomial, B:

p(x) =  1 * x
       -2

  The quotient polynomial, Q:

p(x) =  1 * x^2
       +4 * x
       +3

  The remainder polynomial, R:

p(x) =  0

  The polynomial to be divided, A:

p(x) =  1 * x^4
       +3 * x^3
       +2 * x^2
       +5 * x
       -2

  The divisor polynomial, B:

p(x) =  1 * x^2
       +1 * x
       -3

  The quotient polynomial, Q:

p(x) =  1 * x^2
       +2 * x
       +3

  The remainder polynomial, R:

p(x) =  8 * x
       +7

TEST067
  I4POLY_MUL multiplies two polynomials.


  The factor A:

p(x) =  1 * x
       +1

  The factor B:

p(x) = -1 * x
       +1

  The product C = A*B:

p(x) = -1 * x^2
       +1

  The factor A:

p(x) =  3 * x^2
       +2 * x
       +1

  The factor B:

p(x) = -2 * x
       +1

  The product C = A*B:

p(x) = -6 * x^3
       -1 * x^2
       +1

TEST0675
  I4VEC_DESCENDS is true if an integer vector decreases.


  The integer array to search:

       1         1
       2         4
       3         4
       4         3
  The preceding vector is not descending.

  The integer array to search:

       1         2
       2         1
       3         2
       4         1
  The preceding vector is not descending.

  The integer array to search:

       1         1
       2         3
       3         1
       4         2
  The preceding vector is not descending.

  The integer array to search:

       1         2
       2         4
       3         4
       4         1
  The preceding vector is not descending.

  The integer array to search:

       1         4
       2         2
       3         1
       4         1
  The preceding vector is descending.

TEST068
  I4VEC_FRAC: K-th smallest integer vector entry.


  The integer array to search:

       1         5
       2        20
       3        17
       4        12
       5         9
       6         2
       7         6
       8         3
       9         1
      10        13

     K   K-th smallest

     1       1
     2       2
     3       3
     4       5
     5       6
     6       9
     7      12
     8      13
     9      17
    10      20

TEST0683
  I4VEC_INDEX returns the index of the first occurrence
  of a given value in an integer vector.


  The integer array to search:

       1         3
       2        10
       3         9
       4         6
       5         5
       6         1
       7         3
       8         2
       9         1
      10         7
      11         1
      12         5
      13         5
      14         8
      15         8
      16         1
      17         9
      18         4
      19         1
      20         1

  The value searched for is 1
  The index of first occurrence is 5

TEST0685
  I4VEC_MAXLOC_LAST: index of the last maximal
  entry in an integer vector.


  The integer array to search:

       1         2
       2         5
       3         5
       4         3
       5         3
       6         1
       7         2
       8         1
       9         1
      10         4
      11         1
      12         3
      13         3
      14         4
      15         4
      16         1
      17         5
      18         2
      19         1
      20         1

  Index of last maximal entry is 16

TEST0686
  I4VEC_PAIRWISE_PRIME is true if an integer vector
  is pairwise prime.


  The array to check:

       1         1
       2         4
       3         4
       4         3
  The preceding vector is not pairwise prime.

  The array to check:

       1         2
       2         1
       3         2
       4         1
  The preceding vector is not pairwise prime.

  The array to check:

       1         1
       2         3
       3         1
       4         2
  The preceding vector is pairwise prime.

  The array to check:

       1         2
       2         4
       3         4
       4         1
  The preceding vector is not pairwise prime.

  The array to check:

       1         4
       2         2
       3         1
       4         1
  The preceding vector is not pairwise prime.

TEST0687
  I4VEC_REVERSE reverses an integer vector.


  The integer array:

       1         2
       2         5
       3         5
       4         3
       5         3

  The reversed integer array:

       1         3
       2         3
       3         5
       4         5
       5         2

TEST0688
  I4VEC_SORT_BUBBLE_A ascending sorts an integer vector
    using bubble sort.


  Unsorted array:

       1        13
       2        58
       3        50
       4        34
       5        25
       6         4
       7        15
       8         6
       9         2
      10        38
      11         3
      12        27
      13        24
      14        46
      15        48
      16         0
      17        54
      18        21
      19         5
      20         0

  Sorted array:

       1         0
       2         0
       3         2
       4         3
       5         4
       6         5
       7         6
       8        13
       9        15
      10        21
      11        24
      12        25
      13        27
      14        34
      15        38
      16        46
      17        48
      18        50
      19        54
      20        58

TEST0689
  I4VEC_SORT_HEAP_INDEX_D descending index-sorts
    an integer vector using heap sort.


  Unsorted array:

       1        13
       2        58
       3        50
       4        34
       5        25
       6         4
       7        15
       8         6
       9         2
      10        38
      11         3
      12        27
      13        24
      14        46
      15        48
      16         0
      17        54
      18        21
      19         5
      20         0

     I  INDX[I]  A[INDX[I]-1]

     0       1      58
     1      16      54
     2       2      50
     3      14      48
     4      13      46
     5       9      38
     6       3      34
     7      11      27
     8       4      25
     9      12      24
    10      17      21
    11       6      15
    12       0      13
    13       7       6
    14      18       5
    15       5       4
    16      10       3
    17       8       2
    18      19       0
    19      15       0

TEST06895
  INVERSE_MOD_N seeks Y, the inverse of B mod N,
  so that mod ( B * Y, N ) = 1, but returns 0
  if the inverse does not exist.

     B     N     Y     Z = ( ( B * Y ) % N )

   1   2   1   1
   1   3   1   1
   2   3   2   1
   1   4   1   1
   2   4   0   0
   3   4   3   1
   1   5   1   1
   2   5   3   1
   3   5   2   1
   4   5   4   1
   1   6   1   1
   2   6   0   0
   3   6   0   0
   4   6   0   0
   5   6   5   1
   1   7   1   1
   2   7   4   1
   3   7   5   1
   4   7   2   1
   5   7   3   1
   6   7   6   1
   1   8   1   1
   2   8   0   0
   3   8   3   1
   4   8   0   0
   5   8   5   1
   6   8   0   0
   7   8   7   1
   1   9   1   1
   2   9   5   1
   3   9   0   0
   4   9   7   1
   5   9   2   1
   6   9   0   0
   7   9   4   1
   8   9   8   1
   1  10   1   1
   2  10   0   0
   3  10   7   1
   4  10   0   0
   5  10   0   0
   6  10   0   0
   7  10   3   1
   8  10   0   0
   9  10   9   1

TEST069
  RFRAC_TO_JFRAC converts a rational polynomial
  fraction to a J fraction.
  JFRAC_TO_RFRAC converts a J fraction
  to a rational polynomial fraction.

  The original rational polynomial coefficients:

      0.218418        0.956318        0.829509        0.561695        0.415307       0.0661187  
      0.641848        0.273997        0.109216         1.57976        0.153816         1.12019               1  

  The J fraction coefficients:

     0.0661187         24.0763       -0.310636         1.40276         5.16789      -0.0686133  
      -5.16104         4.91564        -0.94563        -1.04001         2.91888        0.432351  

  The recovered rational polynomial:

      0.218418        0.956318        0.829509        0.561695        0.415307       0.0661187  
      0.641848        0.273997        0.109216         1.57976        0.153816         1.12019               1  

TEST070
  JOSEPHUS solves Josephus problems.

    N    M    K	 X

   41      3     41     31
   41    -38     41     31
   41      3     40     16
   64      2     64      1
 1000      2   1000    977

TEST071
  KSUB_NEXT generates all K subsets of an N set
  in lexicographic order.

   1       1   2   3
   2       1   2   4
   3       1   2   5
   4       1   3   4
   5       1   3   5
   6       1   4   5
   7       2   3   4
   8       2   3   5
   9       2   4   5
  10       3   4   5

TEST072
  KSUB_NEXT2 generates the next K subset of an
  N set by the revolving door method.

Rank  Subset  Added  Removed

   1   1   2   3      0   0
   2   1   3   4      4   2
   3   2   3   4      2   1
   4   1   2   4      1   3
   5   1   4   5      5   2
   6   2   4   5      2   1
   7   3   4   5      3   2
   8   1   3   5      1   4
   9   2   3   5      2   1
  10   1   2   5      1   3

TEST073
  KSUB_NEXT3 generates all K subsets of an N set
  using the revolving door method.

Rank    Subset  Added Removed

   1   1   2   3      0   0
   2   1   3   4      4   2
   3   2   3   4      2   1
   4   1   2   4      1   3
   5   1   4   5      5   2
   6   2   4   5      2   1
   7   3   4   5      3   2
   8   1   3   5      1   4
   9   2   3   5      2   1
  10   1   2   5      1   3

TEST074
  KSUB_NEXT4 generates K subsets of an N set.
  N = 5
  K = 3

Rank    Subset

   1       1     2     3  
   2       1     2     4  
   3       1     3     4  
   4       2     3     4  
   5       1     2     5  
   6       1     3     5  
   7       2     3     5  
   8       1     4     5  
   9       2     4     5  
  10       3     4     5  

TEST075
  KSUB_RANDOM generates a random K subset of an N set.
  Set size is N =    5
  Subset size is K = 3

    2    4    5
    1    2    4
    1    4    5
    1    4    5
    1    3    4

TEST076
  KSUB_RANDOM2 generates a random K subset of an N set.
  Set size is N =    5
  Subset size is K = 3

    1    4    5
    1    2    3
    1    3    4
    1    4    5
    1    2    3

TEST077
  KSUB_RANDOM3 generates a random K subset of an N set.
  Set size is N =    5
  Subset size is K = 3

    1    0    0    1    1
    1    1    0    1    0
    1    0    0    1    1
    1    1    1    0    0
    0    1    0    1    1
    1    1    0    1    0
    1    0    0    1    1
    1    0    1    0    1
    1    0    0    1    1
    0    1    0    1    1

TEST0771
  KSUB_RANDOM4 generates a random K subset of an N set.
  Set size is N =    5
  Subset size is K = 3

    1    2    4
    5    4    3
    4    2    3
    1    4    5
    1    2    5
    4    2    5
    5    2    3
    1    5    4
    1    2    5
    1    2    5

TEST07715
  KSUB_RANDOM5 generates a random K subset of an N set.
  Set size is N =    52
  Subset size is K = 5

   12   24   31   44   50
    4    6    8   15   35
    4   23   24   40   43
    1    5    8   20   47
    4    9   17   44   45

TEST0772
  KSUB_RANK: determine the rank of a K subset of an N set.

  For N = 6
  and K = 3
  the subset is:

   1   3   5

  The computed rank is 6

TEST0773
  KSUB_UNRANK: find the K-subset of an N set
  of a given rank.

  For N = 5
  and K = 3
  and the desired rank is 8

  The subset of the given rank is:

   1   4   5

TEST078
  MATRIX_PRODUCT_OPT seeks the optimal order
  for a chain of matrix products.

  Matrix ranks:

   I    R    C

    0      4      2
    1      2      3
    2      3      1
    3      1      2
    4      2      2
    5      2      3

  Optimal cost is 36

  Ordering:

       1         2
       2         1
       3         4
       4         5
       5         3

TEST079
  MOEBIUS_MATRIX computes the Moebius matrix.

  The input matrix:

  Col:          1             2             3             4             5             6             7             8             9            10       
  Row
  ---
    1       0       0       0       0       0       1       0       0       0       1  
    2       0       0       1       1       0       0       0       0       0       0  
    3       1       0       0       0       0       0       0       0       1       0  
    4       1       0       0       0       1       0       0       0       1       0  
    5       0       0       0       0       0       1       0       0       0       0  
    6       0       0       0       0       0       0       1       0       0       0  
    7       0       0       0       0       0       0       0       0       0       0  
    8       0       1       0       0       0       0       0       0       0       0  
    9       0       0       0       0       0       1       0       0       0       1  
   10       0       0       0       0       0       0       1       0       0       0  
   11       0       0       0       0       0       0       1       0       0       0  

  Col:         11       
  Row
  ---
    1       0  
    2       0  
    3       0  
    4       0  
    5       0  
    6       0  
    7       0  
    8       0  
    9       1  
   10       0  
   11       0  

  The Moebius matrix:

  Col:          1             2             3             4             5             6             7             8             9            10       
  Row
  ---
    1       1       0       0       0       0      -1       1       0       0      -1  
    2       1       1      -1      -1       0      -1       1       0       1      -1  
    3      -1       0       1       0       0       1      -1       0      -1       1  
    4      -1       0       0       1      -1       2      -1       0      -1       1  
    5       0       0       0       0       1      -1       0       0       0       0  
    6       0       0       0       0       0       1      -1       0       0       0  
    7       0       0       0       0       0       0       1       0       0       0  
    8       0      -1       0       0       0       0       0       1       0       0  
    9       0       0       0       0       0      -1       2       0       1      -1  
   10       0       0       0       0       0       0      -1       0       0       1  
   11       0       0       0       0       0       0      -1       0       0       0  

  Col:         11       
  Row
  ---
    1       0  
    2       0  
    3       0  
    4       0  
    5       0  
    6       0  
    7       0  
    8       0  
    9      -1  
   10       0  
   11       1  

TEST0795
  MONOMIAL_COUNT counts the number of monomials of
  degrees 0 through DEGREE_MAX in a space of dimension DIM.
  MONOMIAL_COUNTS provides individual counts.

  DIM = 1

         0         1
         1         1
         2         1
         3         1
         4         1
         5         1
         6         1
         7         1
         8         1
         9         1
        10         1

     Total        11        11

  DIM = 2

         0         1
         1         2
         2         3
         3         4
         4         5
         5         6
         6         7
         7         8
         8         9
         9        10
        10        11

     Total        66        66

  DIM = 3

         0         1
         1         3
         2         6
         3        10
         4        15
         5        21
         6        28
         7        36
         8        45
         9        55
        10        66

     Total       286       286

  DIM = 4

         0         1
         1         4
         2        10
         3        20
         4        35
         5        56
         6        84
         7       120
         8       165
         9       220
        10       286

     Total      1001      1001

  DIM = 5

         0         1
         1         5
         2        15
         3        35
         4        70
         5       126
         6       210
         7       330
         8       495
         9       715
        10      1001

     Total      3003      3003

  DIM = 6

         0         1
         1         6
         2        21
         3        56
         4       126
         5       252
         6       462
         7       792
         8      1287
         9      2002
        10      3003

     Total      8008      8008

TEST080
  MORSE_THUE computes the Morse-Thue numbers.

  0110100110
  0101101001
  0110011010
  0110010110
  0110100101
  1010011001
  0110100101
  1001101001
  0110100110
  0101100110
  1

TEST081
  MULTINOMIAL_COEF1 computes multinomial
    coefficients using the Gamma function;
  MULTINOMIAL_COEF2 computes multinomial
    coefficients directly.

  Line 10 of the BINOMIAL table:

   0    10          1      1
   1     9         10     10
   2     8         45     45
   3     7        120    120
   4     6        210    210
   5     5        252    252
   6     4        210    210
   7     3        120    120
   8     2         45     45
   9     1         10     10
  10     0          1      1

  Level 5 of the TRINOMIAL coefficients:

   0     0     5          1      1
   0     1     4          5      5
   0     2     3         10     10
   0     3     2         10     10
   0     4     1          5      5
   0     5     0          1      1

   1     0     4          5      5
   1     1     3         20     20
   1     2     2         30     30
   1     3     1         20     20
   1     4     0          5      5

   2     0     3         10     10
   2     1     2         30     30
   2     2     1         30     30
   2     3     0         10     10

   3     0     2         10     10
   3     1     1         20     20
   3     2     0         10     10

   4     0     1          5      5
   4     1     0          5      5

   5     0     0          1      1

TEST0813
  MULTIPERM_ENUM enumerates multipermutations.

  N is the number of objects to be permuted.
  K is the number of distinct types of objects.
  COUNTS is the number of objects of each type.
  NUMBER is the number of multipermutations.

  Number       N       K       Counts(1:K)

       5       5       2     4     1
      20       5       3     1     1     3
      60       5       4     1     1     2     1
       5       5       2     1     4
     120       5       5     1     1     1     1     1

TEST0815
  MULTIPERM_NEXT computes multipermutations in
  lexical order.

     1   1   2   2   3   3   3
     2   1   2   3   2   3   3
     3   1   2   3   3   2   3
     4   1   2   3   3   3   2
     5   1   3   2   2   3   3
     6   1   3   2   3   2   3
     7   1   3   2   3   3   2
     8   1   3   3   2   2   3
     9   1   3   3   2   3   2
    10   1   3   3   3   2   2
    11   2   1   2   3   3   3
    12   2   1   3   2   3   3
    13   2   1   3   3   2   3
    14   2   1   3   3   3   2
    15   2   2   1   3   3   3
    16   2   2   3   1   3   3
    17   2   2   3   3   1   3
    18   2   2   3   3   3   1
    19   2   3   1   2   3   3
    20   2   3   1   3   2   3
    21   2   3   1   3   3   2
    22   2   3   2   1   3   3
    23   2   3   2   3   1   3
    24   2   3   2   3   3   1
    25   2   3   3   1   2   3
    26   2   3   3   1   3   2
    27   2   3   3   2   1   3
    28   2   3   3   2   3   1
    29   2   3   3   3   1   2
    30   2   3   3   3   2   1
    31   3   1   2   2   3   3
    32   3   1   2   3   2   3
    33   3   1   2   3   3   2
    34   3   1   3   2   2   3
    35   3   1   3   2   3   2
    36   3   1   3   3   2   2
    37   3   2   1   2   3   3
    38   3   2   1   3   2   3
    39   3   2   1   3   3   2
    40   3   2   2   1   3   3
    41   3   2   2   3   1   3
    42   3   2   2   3   3   1
    43   3   2   3   1   2   3
    44   3   2   3   1   3   2
    45   3   2   3   2   1   3
    46   3   2   3   2   3   1
    47   3   2   3   3   1   2
    48   3   2   3   3   2   1
    49   3   3   1   2   2   3
    50   3   3   1   2   3   2
    51   3   3   1   3   2   2
    52   3   3   2   1   2   3
    53   3   3   2   1   3   2
    54   3   3   2   2   1   3
    55   3   3   2   2   3   1
    56   3   3   2   3   1   2
    57   3   3   2   3   2   1
    58   3   3   3   1   2   2
    59   3   3   3   2   1   2
    60   3   3   3   2   2   1

TEST083
  NIM_SUM computes the Nim sum of two integers.

    I    J    Nim(I+J)


  I1, I2, I3 in decimal:

    218
    957
    871

  I1, I2, I3 in binary:


 

   00000000000000000000000011011010

 

   00000000000000000000001110111101

 

   00000000000000000000001101100111

  I1, I2, I3 in decimal:

    830
    562
    268

  I1, I2, I3 in binary:


 

   00000000000000000000001100111110

 

   00000000000000000000001000110010

 

   00000000000000000000000100001100

  I1, I2, I3 in decimal:

    415
     66
    477

  I1, I2, I3 in binary:


 

   00000000000000000000000110011111

 

   00000000000000000000000001000010

 

   00000000000000000000000111011101

  I1, I2, I3 in decimal:

    257
    110
    367

  I1, I2, I3 in binary:


 

   00000000000000000000000100000001

 

   00000000000000000000000001101110

 

   00000000000000000000000101101111

  I1, I2, I3 in decimal:

     43
    634
    593

  I1, I2, I3 in binary:


 

   00000000000000000000000000101011

 

   00000000000000000000001001111010

 

   00000000000000000000001001010001

TEST0835
  PADOVAN computes the Padovan numbers.


   N    P(N)

     0       1
     1       1
     2       1
     3       2
     4       2
     5       3
     6       4
     7       5
     8       7
     9       9

TEST084
  PELL_BASIC solves the basic Pell equation.
  PELL_NEXT computes the next solution.

       D       X        Y         R

        2          3          2          1
                  17         12          1
        3          2          1          1
                   7          4          1
        5          9          4          1
                 161         72          1
        6          5          2          1
                  49         20          1
        7          8          3          1
                 127         48          1
        8          3          1          1
                  17          6          1
       10         19          6          1
                 721        228          1
       11         10          3          1
                 199         60          1
       12          7          2          1
                  97         28          1
       13        649        180          1
              842401     233640          1
       14         15          4          1
                 449        120          1
       15          4          1          1
                  31          8          1
       17         33          8          1
                2177        528          1
       18         17          4          1
                 577        136          1
       19        170         39          1
               57799      13260          1
       20          9          2          1
                 161         36          1

TEST085
  PENT_ENUM counts points in pentagons.

   N  Pent(N)

   0       0
   1       1
   2       5
   3      12
   4      22
   5      35
   6      51
   7      70
   8      92
   9     117
  10     145

TEST086
  PERM_BREAK_COUNT counts the breaks in a permutation.

  The permutation:

     0   1   2   3   4   5
     4   5   2   1   6   3

  The number of breaks is 5

TEST087
  PERM_CANON_TO_CYCLE converts a permutation from
  canonical to cycle form.

  The permutation in canonical form:

     0   1   2   3   4   5
     4   5   2   1   6   3

  The permutation in cycle form:

     0   1   2   3   4   5
    -4   5  -2  -1   6   3

TEST088
  PERM_CYCLE analyzes a permutation.

  The permutation:

     0   1   2   3   4   5   6   7   8
     2   3   9   6   7   8   5   4   1

  NCYCLE = 3
  ISGN =   1

  The permutation in cycle form:

     0   1   2   3   4   5   6   7   8
    -2   3   9  -6  -7   8   5   4   1

TEST089
  PERM_CYCLE_TO_CANON converts a permutation from
  cycle to canonical form.

  The permutation in cycle form:

     0   1   2   3   4   5
    -6   3   1  -5   4  -2

  The permutation in canonical form:

     0   1   2   3   4   5
     4   5   2   1   6   3

TEST090
  PERM_CYCLE_TO_INDEX converts a permutation from
    cycle to standard index form.
  PERM_INDEX_TO_CYCLE converts a permutation from
    standard index to cycle form.

  The standard index form permutation:

     0   1   2   3   4   5   6   7   8
     2   3   9   6   7   8   5   4   1

  The permutation in cycle form:

     0   1   2   3   4   5   6   7   8
    -1   2   3   9  -4   6   8  -5   7

  The standard index form permutation:

     0   1   2   3   4   5   6   7   8
     2   3   9   6   7   8   5   4   1

TEST091
  PERM_DISTANCE computes the Ulam metric distance
  between two permutations.

  Permutation P1

     0   1   2   3   4   5   6   7   8   9
     4   3   2  10   1   7   9   6   8   5

  Permutation P2

     0   1   2   3   4   5   6   7   8   9
     9   3   5   7   8   6   1   4  10   2

  Permutation P3

     0   1   2   3   4   5   6   7   8   9
     2   4   1   3   8   6   9   7  10   5

  K(P1,P1) should be 0.

  K(P1,P1) = 0

  K(P1,P2) should equal K(P2,P1).

  K(P1,P2) = 7
  K(P2,P1) = 7

  K(P1,P2) + K(P2,P3) >= K(P1,P3).

  K(P1,P3) = 6
  K(P1,P2) = 7
  K(P2,P3) = 6
  K(P1,P2) + K(P2,P3) = 13

TEST092
  PERM_FIXED_ENUM enumerates the permutations
  of N objects that leave M unchanged.

  For this test, N = 10

    M    F(N,M)

    0   1334961
    1   1334960
    2    667485
    3    222480
    4     55650
    5     11088
    6      1890
    7       240
    8        45
    9         0
   10         1

TEST093
  PERM_ASCEND determines the length of the longest
  increasing subsequence in a permutation.

  The permutation:

     0   1   2   3   4   5   6   7   8
     2   3   9   6   7   8   5   4   1

  The length of the longest increasing subsequence is 5

  A longest increasing subsequence:

       1         2
       2         3
       3         6
       4         7
       5         8

TEST094
  PERM_INVERSE inverts a permutation in place;


  The original permutation:

     0   1   2   3   4   5   6
     4   3   5   1   7   6   2

  The inverted permutation:

     0   1   2   3   4   5   6
     4   7   2   1   3   6   5

TEST095
  PERM_INVERSE2 inverts a permutation in place.

  The original permutation:

     0   1   2   3   4   5   6
     4   3   5   1   7   6   2

  The inverted permutation:

     0   1   2   3   4   5   6
     4   7   2   1   3   6   5

TEST0955
  PERM_INVERSE3_NEW inverts a permutation.

  The original permutation:

     0   1   2   3   4   5   6
     3   2   4   0   6   5   1

  The inverted permutation:

     0   1   2   3   4   5   6
     3   6   1   0   2   5   4

TEST096
  PERM_LEX_NEXT generates permutations in order.

     1   2   3   4
     1   2   4   3
     1   3   2   4
     1   3   4   2
     1   4   2   3
     1   4   3   2
     2   1   3   4
     2   1   4   3
     2   3   1   4
     2   3   4   1
     2   4   1   3
     2   4   3   1
     3   1   2   4
     3   1   4   2
     3   2   1   4
     3   2   4   1
     3   4   1   2
     3   4   2   1
     4   1   2   3
     4   1   3   2
     4   2   1   3
     4   2   3   1
     4   3   1   2
     4   3   2   1

TEST097
  PERM_LEX_NEXT generates permutations in order.
  PERM_SIGN computes the sign of a permutation.

  RANK  SIGN  Permutation

   0     1     1     2     3     4  
   1    -1     1     2     4     3  
   2    -1     1     3     2     4  
   3     1     1     3     4     2  
   4     1     1     4     2     3  
   5    -1     1     4     3     2  
   6    -1     2     1     3     4  
   7     1     2     1     4     3  
   8     1     2     3     1     4  
   9    -1     2     3     4     1  
  10    -1     2     4     1     3  
  11     1     2     4     3     1  
  12     1     3     1     2     4  
  13    -1     3     1     4     2  
  14    -1     3     2     1     4  
  15     1     3     2     4     1  
  16     1     3     4     1     2  
  17    -1     3     4     2     1  
  18    -1     4     1     2     3  
  19     1     4     1     3     2  
  20     1     4     2     1     3  
  21    -1     4     2     3     1  
  22    -1     4     3     1     2  
  23     1     4     3     2     1  

TEST098
  PERM_MUL multiplies two permutations.


  Permutation P1:

     0   1   2   3   4
     2   5   1   3   4

  Permutation P2:

     0   1   2   3   4
     1   3   2   4   5

  Product permutation: P3

     0   1   2   3   4
     3   5   1   2   4

TEST099
  PERM_NEXT generates permutations.

     1   2   3   4
     2   1   3   4
     3   1   2   4
     1   3   2   4
     2   3   1   4
     3   2   1   4
     4   2   1   3
     2   4   1   3
     1   4   2   3
     4   1   2   3
     2   1   4   3
     1   2   4   3
     1   3   4   2
     3   1   4   2
     4   1   3   2
     1   4   3   2
     3   4   1   2
     4   3   1   2
     4   3   2   1
     3   4   2   1
     2   4   3   1
     4   2   3   1
     3   2   4   1
     2   3   4   1

TEST100
  PERM_NEXT2 generates permutations in order.

     1   2   3   4
     1   2   4   3
     1   4   2   3
     4   1   2   3
     4   1   3   2
     1   4   3   2
     1   3   4   2
     1   3   2   4
     3   1   2   4
     3   1   4   2
     3   4   1   2
     4   3   1   2
     4   3   2   1
     3   4   2   1
     3   2   4   1
     3   2   1   4
     2   3   1   4
     2   3   4   1
     2   4   3   1
     4   2   3   1
     4   2   1   3
     2   4   1   3
     2   1   4   3
     2   1   3   4

TEST101
  PERM_NEXT3 generates permutations in order.

     1   2   3   4
     1   2   4   3
     1   4   2   3
     4   1   2   3
     4   1   3   2
     1   4   3   2
     1   3   4   2
     1   3   2   4
     3   1   2   4
     3   1   4   2
     3   4   1   2
     4   3   1   2
     4   3   2   1
     3   4   2   1
     3   2   4   1
     3   2   1   4
     2   3   1   4
     2   3   4   1
     2   4   3   1
     4   2   3   1
     4   2   1   3
     2   4   1   3
     2   1   4   3
     2   1   3   4

TEST102
  PERM_RANDOM produces a random permutation;
  For this test, N = 4

     1   4   2   3
     2   1   3   4
     1   3   2   4
     2   4   1   3
     4   3   2   1

TEST103
  PERM_RANDOM2 produces a random permutation;
  For this test, N = 4

   101 404 202 303
   202 101 303 404
   101 303 202 404
   202 404 101 303
   404 303 202 101

TEST104
  PERM_RANDOM3 produces a random permutation;
  For this test, N = 4

     2   1   4   3
     4   1   3   2
     1   3   4   2
     4   2   1   3
     3   4   2   1

TEST105
  PERM_RANK ranks a permutation.

  The permutation:

     0   1   2   3
     1   4   2   3

  The rank is 3

TEST106
  PERM_TO_EQUIV returns the set partition
  or equivalence classes determined by a
  permutation.

  The input permutation:

     0   1   2   3   4   5   6   7   8
     2   3   9   6   7   8   5   4   1

  The partition:

  Set    Size  Elements
     1     4 ::    1     2     3     9  
     2     3 ::    4     6     8  
     3     2 ::    5     7  

TEST107
  PERM_TO_YTB converts a permutation to a
  Young tableau.

  The permutation:

     0   1   2   3   4   5   6
     7   2   4   1   5   3   6

  The Young tableau:

     1       3       5       6  
     2       4  
     7  

TEST108
  PERM_UNRANK, given a rank, computes the
  corresponding permutation.

  The requested rank is 6

  The permutation:

     0   1   2   3
     1   4   3   2

TEST1085
  PERRIN computes the Perrin numbers.


   N    P(N)

     0       3
     1       0
     2       2
     3       3
     4       2
     5       5
     6       5
     7       7
     8      10
     9      12

TEST109
  POWER_MOD computes the remainder of a power
  of an integer modulo another integer.

  A = 7
  N = 50
  M = 11
  mod ( A**N, M ) = 1

  A = 3
  N = 118
  M = 119
  mod ( A**N, M ) = 32

TEST110
  POWER_SERIES1 composes a power series;

  Power series of G(x) = (1+F(x))**alpha

  N = 10
  ALPHA = 7

  Series for F(x):

         0             1
         1             0
         2             0
         3             0
         4             0
         5             0
         6             0
         7             0
         8             0
         9             0

  Series for G(X):

         0             7
         1            21
         2            35
         3            35
         4            21
         5             7
         6             1
         7             0
         8             0
         9             0

TEST111
  POWER_SERIES2 composes a power series;

  Power series of G(x) = exp(F(x))-1

  N = 4

  Series for F(X):

         0            -4
         1             0
         2             0
         3             0

  Series for G(X):

         0            -4
         1             8
         2      -10.6667
         3       10.6667

TEST112
  POWER_SERIES3 composes two power series;

  Series for F(X):

         0             1
         1             1
         2             0
         3             0

  Series for G(X):

         0             1
         1             1
         2             0
         3             0

  Series for H(X) = G(F(X)):

         0             1
         1             2
         2             2
         3             3

TEST113
  POWER_SERIES4 composes a power series;
  Given power series for F(X) and G(X), we compute
  the power series of H(x) = G(1/F(x)).

  Series for F(x):

         0             1
         1           0.5
         2      0.333333
         3          0.25
         4           0.2
         5      0.166667
         6      0.142857
         7         0.125
         8      0.111111
         9           0.1

  Series for G(x):

         0             1
         1             0
         2             0
         3             0
         4             0
         5             0
         6             0
         7             0
         8             0
         9             0

  Series for H(x):

         0             1
         1          -0.5
         2      0.166667
         3    -0.0416667
         4    0.00833333
         5   -0.00138889
         6   0.000198413
         7  -2.48016e-05
         8   2.75573e-06
         9  -2.75573e-07

TEST114
  PYTHAG_TRIPLE_NEXT computes the next
    Pythagorean triple.

     I       J       A       B       C A^2+B^2     C^2

     2       1       3       4       5      25      25
     3       2       5      12      13     169     169
     4       1      15       8      17     289     289
     4       3       7      24      25     625     625
     5       2      21      20      29     841     841
     5       4       9      40      41    1681    1681
     6       1      35      12      37    1369    1369
     6       3      27      36      45    2025    2025
     6       5      11      60      61    3721    3721
     7       2      45      28      53    2809    2809
     7       4      33      56      65    4225    4225
     7       6      13      84      85    7225    7225
     8       1      63      16      65    4225    4225
     8       3      55      48      73    5329    5329
     8       5      39      80      89    7921    7921
     8       7      15     112     113   12769   12769
     9       2      77      36      85    7225    7225
     9       4      65      72      97    9409    9409
     9       6      45     108     117   13689   13689
     9       8      17     144     145   21025   21025
    10       1      99      20     101   10201   10201

TEST115
  R8_AGM computes the arithmetic-geometric mean (AGM)
  of two nonnegative real numbers.

    X        Y    R8_AGM(X,Y)

         3          10     5.97767
         9           6     7.42404
         5           1     2.60401
         3           2     2.47468
         1           7     3.28792
         1           5     2.60401
         5           8     6.41198
         8           1     3.61576
         9           4      6.2475
         1           1           1

TEST030
  R8_FALL computes the falling factorial function.
  [X]_N = X * (X-1) * (X-2) * ... * ( X-N+1).

    X          N  R8_FALL(X,N)

         4        -2          20
         4        -1           4
         4         0           1
         4         1           4
         4         2          12
         4         3          24
         4         4          24
         4         5           0

TEST1245
  R8_RISE computes the rising factorial function.
  [X]_N = X * (X+1) * (X+2) * ... * ( X+N-1).

    X          N  R8_RISE(X,N)

         4        -2          12
         4        -1           4
         4         0           1
         4         1           4
         4         2          20
         4         3         120
         4         4         840
         4         5        6720

TEST1155
  R8_EPSILON produces the floating point machine precision.

  R = R8_EPSILON() = 2.22045e-16
  ( 1 + R ) - 1 = 2.22045e-16
  ( 1 + (R/2) ) - 1 =          0

TEST116
  R8_TO_CFRAC converts a real number to a sequence
  of continued fraction convergents.

  Use the real number R = 6.28319

 I        A[I]      P[I+1]      Q[I+1]   P[I]/Q[I]    Error

   0           6           6           1               6        0.283185
   1           3          19           3         6.33333       -0.050148
   2           1          25           4            6.25       0.0331853
   3           1          44           7         6.28571     -0.00252898
   4           7         333          53         6.28302     0.000166439
   5           2         710         113         6.28319    -5.33528e-07
   6         146      103993       16551         6.28319     1.15578e-09
   7           3      312689       49766         6.28319    -5.82867e-11

TEST1163
  R8_TO_DEC converts a real number to a decimal;
  DEC_TO_R8 converts a decimal to a real number.

  The maximum number of digits allowed is 5

     R   =>  A * 10^B  =>  R2

   -0.315817  -31582      -5    -0.31582
     7.06318   70632      -4      7.0632
     5.79509   57951      -4      5.7951
     3.11695    3117      -3       3.117
     1.65307   16531      -4      1.6531
    -1.83881  -18388      -4     -1.8388
   0.0757779   75778      -6    0.075778
    -1.40043  -14004      -4     -1.4004
    -2.06171  -20617      -4     -2.0617
     3.83966   38397      -4      3.8397

TEST1165
  R8_TO_RAT converts a real number to a rational;
  RAT_TO_R8 converts a rational to a real number.

  The maximum number of digits allowed is 4

     R   =>  A / B  =>  R2

   -0.315817   -1579    5000     -0.3158
     7.06318    8829    1250      7.0632
     5.79509   57951   10000      5.7951
     3.11695    3117    1000       3.117
     1.65307   16531   10000      1.6531
    -1.83881   -4597    2500     -1.8388
   0.0757779     379    5000      0.0758
    -1.40043   -3501    2500     -1.4004
    -2.06171  -20617   10000     -2.0617
     3.83966   38397   10000      3.8397

TEST117
  RAT_ADD adds two rationals.

  A = 3/4
  B = 10/7
  C = A + B = 61/28

TEST118
  RAT_DIV divides two rationals.

  A = 3/4
  B = 10/7
  C = A / B = 21/40

TEST119
  RAT_FAREY computes a row of the Farey fraction table.

  Row 1
  Number of fractions: 2

  0  1
  1  1

  Row 2
  Number of fractions: 3

  0  1  1
  1  2  1

  Row 3
  Number of fractions: 5

  0  1  1  2  1
  1  3  2  3  1

  Row 4
  Number of fractions: 7

  0  1  1  1  2  3  1
  1  4  3  2  3  4  1

  Row 5
  Number of fractions: 11

  0  1  1  1  2  1  3  2  3  4  1
  1  5  4  3  5  2  5  3  4  5  1

  Row 6
  Number of fractions: 13

  0  1  1  1  1  2  1  3  2  3  4  5  1
  1  6  5  4  3  5  2  5  3  4  5  6  1

  Row 7
  Number of fractions: 19

  0  1  1  1  1  2  1  2  3  1  4  3  2  5  3  4  5  6  1
  1  7  6  5  4  7  3  5  7  2  7  5  3  7  4  5  6  7  1

TEST120
  RAT_FAREY2 computes a row of the Farey fraction table.

  Row 1

  0  1
  1  1

  Row 2

  0  1  1
  1  2  1

  Row 3

  0  1  1  2  1
  1  3  2  3  1

  Row 4

  0  1  1  2  1  3  2  3  1
  1  4  3  5  2  5  3  4  1

  Row 5

  0  1  1  2  1  3  2  3  1  4  3  5  2  5  3  4  1
  1  5  4  7  3  8  5  7  2  7  5  8  3  7  4  5  1

TEST121
  RAT_MUL multiplies two rationals.

  A = 3/4
  B = 10/7
  C = A * B = 15/14

TEST1215
  RAT_WIDTH determines the "width" of a rational.

  Top    Bottom  Width

      1000         3         4
      1000        40         4
      1000       500         4
      1000      6000         4
      1000     70000         5
         1         1         1
        -1       200         3
       -10       200         3
      -100       200         4
     -1000       200         5
         1      -200         3
        10      -200         3
       100      -200         4
      1000      -200         5
     10000      -200         6
        17      3000         4
   4000000   4000000         7

TEST122
  RAT_SUM_FORMULA computes the coefficients for the
  formulas for the sums of powers of integers.

  Power Sum Coefficients:

   1     0     0     0     0     0     0  

   1     1     0     0     0     0     0  
   2     2     1     1     1     1     1  

   1     1     1     0     0     0     0  
   3     2     6     1     1     1     1  

   1     1     1     0     0     0     0  
   4     2     4     1     1     1     1  

   1     1     1     0    -1     0     0  
   5     2     3     1    30     1     1  

   1     1     5     0    -1     0     0  
   6     2    12     1    12     1     1  

   1     1     1     0    -1     0     1  
   7     2     2     1     6     1    42  

TEST123
  RATMAT_DET: determinant of a rational matrix.


  The 123/456/789 matrix:

  1    2    3  

  4    5    6  

  7    8    9  

  Determinant of the 123/456/789 matrix = 0/1

  The Hilbert matrix:

  1    1    1  
  2    3    4  

  1    1    1  
  3    4    5  

  1    1    1  
  4    5    6  

  Determinant of the Hilbert matrix = 1/43200

  The -1 2 -1 matrix:

   2    -1     0  

  -1     2    -1  

   0    -1     2  

  Determinant of the -1,2,-1 matrix = 4/1

TEST124
  REGRO_NEXT generates all restricted growth
  functions.

    1  1  1  1  1  
    2  1  1  1  2  
    3  1  1  2  1  
    4  1  1  2  2  
    5  1  1  2  3  
    6  1  2  1  1  
    7  1  2  1  2  
    8  1  2  1  3  
    9  1  2  2  1  
   10  1  2  2  2  
   11  1  2  2  3  
   12  1  2  3  1  
   13  1  2  3  2  
   14  1  2  3  3  
   15  1  2  3  4  

TEST125
  R8MAT_DET: determinant of a real matrix.


  The 123/456/789 matrix:

  Col:          1             2             3       
  Row
  ---
    1             1             2             3  
    2             4             5             6  
    3             7             8             9  

  Determinant of the 123/456/789 matrix is 0

  The Hilbert matrix:

  Col:          1             2             3             4       
  Row
  ---
    1           0.5      0.333333          0.25           0.2  
    2      0.333333          0.25           0.2      0.166667  
    3          0.25           0.2      0.166667      0.142857  
    4           0.2      0.166667      0.142857         0.125  

  Determinant of the Hilbert matrix is 2.36206e-09

  The -1,2,-1 matrix:

  Col:          1             2             3       
  Row
  ---
    1             2            -1             0  
    2            -1             2            -1  
    3             0            -1             2  

  Determinant of the -1,2,-1 matrix is 4

TEST126
  R8MAT_PERM reorders a real matrix in place.
  The rows and columns use the same permutation.

  The original matrix

  Col:          1             2             3             4             5       
  Row
  ---
    1            11            12            13            14            15  
    2            21            22            23            24            25  
    3            31            32            33            34            35  
    4            41            42            43            44            45  
    5            51            52            53            54            55  
    6            61            62            63            64            65  
    7            71            72            73            74            75  
    8            81            82            83            84            85  
    9            91            92            93            94            95  

  Col:          6             7             8             9       
  Row
  ---
    1            16            17            18            19  
    2            26            27            28            29  
    3            36            37            38            39  
    4            46            47            48            49  
    5            56            57            58            59  
    6            66            67            68            69  
    7            76            77            78            79  
    8            86            87            88            89  
    9            96            97            98            99  

  The row and column permutation:

     0   1   2   3   4   5   6   7   8
     2   3   9   6   7   8   5   4   1

  The permuted matrix

  Col:          1             2             3             4             5       
  Row
  ---
    1            99            91            92            98            97  
    2            19            11            12            18            17  
    3            29            21            22            28            27  
    4            89            81            82            88            87  
    5            79            71            72            78            77  
    6            49            41            42            48            47  
    7            59            51            52            58            57  
    8            69            61            62            68            67  
    9            39            31            32            38            37  

  Col:          6             7             8             9       
  Row
  ---
    1            94            95            96            93  
    2            14            15            16            13  
    3            24            25            26            23  
    4            84            85            86            83  
    5            74            75            76            73  
    6            44            45            46            43  
    7            54            55            56            53  
    8            64            65            66            63  
    9            34            35            36            33  

TEST127
  R8MAT_PERM2 reorders a real matrix in place.
  Rows and columns use different permutations.

  The original matrix

  Col:          1             2             3             4             5       
  Row
  ---
    1            11            12            13            14            15  
    2            21            22            23            24            25  
    3            31            32            33            34            35  
    4            41            42            43            44            45  
    5            51            52            53            54            55  
    6            61            62            63            64            65  
    7            71            72            73            74            75  
    8            81            82            83            84            85  
    9            91            92            93            94            95  

  Col:          6             7       
  Row
  ---
    1            16            17  
    2            26            27  
    3            36            37  
    4            46            47  
    5            56            57  
    6            66            67  
    7            76            77  
    8            86            87  
    9            96            97  

  The row permutation:

     0   1   2   3   4   5   6   7   8
     2   3   9   6   7   8   5   4   1

  The column permutation:

     0   1   2   3   4   5   6
     3   4   5   6   7   1   2

  The permuted matrix

  Col:          1             2             3             4             5       
  Row
  ---
    1            24            85            71            32            82  
    2            94            56            41            42            53  
    3            15            46            51            12            81  
    4            43            16            61            72            14  
    5            65            26            31            11            73  
    6            35            36            25            33            83  
    7            45            95            91            92            93  
    8            55            21            52            13            63  
    9            75            66            22            23            34  

  Col:          6             7       
  Row
  ---
    1            62            17  
    2            84            27  
    3            54            37  
    4            64            47  
    5            74            57  
    6            44            67  
    7            76            77  
    8            86            87  
    9            96            97  

TEST128
  R8MAT_PERMANENT: the matrix permanent function.
  We will analyze matrices with 0 diagonal and
  1 on all offdiagonals.

  Order	    Permanent.

DEBUG
   2           1
DEBUG, N = 2
   3           2
DEBUG, N = 3
   4           9
DEBUG, N = 4
   5          44
DEBUG, N = 5
   6         265
DEBUG, N = 6
   7        1854
DEBUG, N = 7
   8       14833
DEBUG, N = 8
   9      133496
DEBUG, N = 9
  10  1.33496e+06
DEBUG, N = 10
  11  1.46846e+07
DEBUG, N = 11
  12  1.76215e+08
DEBUG, N = 12

TEST129
  R8POLY converts between power sum, factorial
  and Taylor forms, and can evaluate a polynomial


  All calls  have input A as follows:

         0             0
         1             0
         2             0
         3             0
         4             0
         5             1

  Option IOPT = -3

  Output array:

         0             0
         1            24
         2           -50
         3            35
         4           -10
         5             1

  Option IOPT = -2

  Output array:

         0             0
         1             1
         2            15
         3            25
         4            10
         5             1

  Option IOPT = -1
  X0 = 2
  Value = 0

  Option IOPT = 0
  X0 = 2
  Value = 32

  Option IOPT = 6
  X0 = 2

  Output array:

         0            32
         1            80
         2            80
         3            40
         4            10
         5             1

  Option IOPT = 6
  X0 = -2

  Output array:

         0           -32
         1            80
         2           -80
         3            40
         4           -10
         5             1

TEST130
  R8POLY_DIV computes the quotient and
  remainder for polynomial division.


  The polynomial to be divided, A:

  p(x) =  1 * x^3
         +2 * x^2
         -5 * x
         -6

  The divisor polynomial, B:

  p(x) =  1 * x
         -2

  The quotient polynomial, Q:

  p(x) =  1 * x^2
         +4 * x
         +3

  The remainder polynomial, R:

  p(x) =  0

  The polynomial to be divided, A:

  p(x) =  1 * x^4
         +3 * x^3
         +2 * x^2
         +5 * x
         -2

  The divisor polynomial, B:

  p(x) =  1 * x^2
         +1 * x
         -3

  The quotient polynomial, Q:

  p(x) =  1 * x^2
         +2 * x
         +3

  The remainder polynomial, R:

  p(x) =  8 * x
         +7

TEST131
  R8POLY_P2F: power sum => factorial;
  R8POLY_F2P: factorial => power sum.

  The power sum polynomial:

  p(x) =  4 * x^3
         +3 * x^2
         +2 * x
         +1

  The factorial coefficients:

         0             1
         1             9
         2            15
         3             4

  The recovered power sum polynomial:

  p(x) =  4 * x^3
         +3 * x^2
         +2 * x
         +1

TEST132
  R8POLY_FVAL evaluates a polynomial in factorial form.

  The factorial coefficients:

         0             1
         1             2
         2             3
         3             4
         4             5

  RPOLY (2) = 11
  The correct value is 11.

TEST133
  R8POLY_MUL multiplies two polynomials.


  The factor A:

  p(x) =  1 * x
         +1

  The factor B:

  p(x) = -1 * x
         +1

  The product C = A*B:

  p(x) = -1 * x^2
         +1

  The factor A:

  p(x) =  3 * x^2
         +2 * x
         +1

  The factor B:

  p(x) = -2 * x
         +1

  The product C = A*B:

  p(x) = -6 * x^3
         -1 * x^2
         +1

TEST134
  R8POLY_N2P: Newton => power sum;
  R8POLY_P2N: Power sum => Newton.

  The power sum polynomial:

  p(x) =  4 * x^3
         +3 * x^2
         +2 * x
         +1

  Derived Newton form coefficients:

         0            49
         1           132
         2            51
         3             4

  Newton form abscissas:

         0             2
         1             4
         2             6
         3             8

  The recovered power sum polynomial:

  p(x) =  4 * x^3
         +3 * x^2
         +2 * x
         +1

TEST135
  R8POLY_NVAL evaluates a polynomial in Newton form.

  Newton polynomial coefficients:

         0             1
         1             2
         2             3
         3             4
         4             5

  Newton polynomial abscissas:

         0             0
         1             1
         2             2
         3             3
         4             4

  RPOLY (2) = 11
  The correct value is 11.

TEST136
  R8POLY_T2P: Taylor => Power sum;
  R8POLY_P2T: Power sum => Taylor.
  The Taylor form uses the base point X0 = 2

  Initial Taylor sum form:

         0             1
         1             2
         2             3
         3             4

  Power sum form:

  p(x) =  5 * x^4
         +4 * x^3
         -21 * x^2
         +38 * x
         -23

  Recovered Taylor sum form:

         0             1
         1             2
         2             3
         3             4

TEST137
  R8POLY_POWER takes a polynomial to a power.

  The polynomial A:

  p(x) = -1 * x
         +2

  Raised to the power 3:

  p(x) =  0

  The polynomial A:

  p(x) =  1 * x^2
         +1 * x

  Raised to the power 2:

  p(x) =  1 * x^4
         +2 * x^3
         +1 * x^2

TEST138
  R8POLY_PVAL evaluates a polynomial
  in power sum form.

  The polynomial to be evaluated:

  p(x) =  5 * x^4
         +4 * x^3
         +3 * x^2
         +2 * x
         +1
  At X = 2
  Computed polynomial value is 129
  Correct value is 129.

TEST139
  R8VEC_FRAC: K-th smallest real vector entry;

  The real array to search: 

         0       2.18418
         1       9.56318
         2       8.29509
         3       5.61695
         4       4.15307
         5      0.661187
         6       2.57578
         7       1.09957
         8       0.43829
         9       6.33966

Frac     Value

   1     0.43829
   2    0.661187
   3     1.09957
   4     2.18418
   5     2.57578
   6     4.15307
   7     5.61695
   8     6.33966
   9     8.29509
  10     9.56318

TEST1395
  R8VEC_MIRROR_NEXT generates all sign variations
    of a real vector.

  Next vector:

         0             1
         1             2
         2             3

  Next vector:

         0            -1
         1             2
         2             3

  Next vector:

         0             1
         1            -2
         2             3

  Next vector:

         0            -1
         1            -2
         2             3

  Next vector:

         0             1
         1             2
         2            -3

  Next vector:

         0            -1
         1             2
         2            -3

  Next vector:

         0             1
         1            -2
         2            -3

  Next vector:

         0            -1
         1            -2
         2            -3

  Done.

  Next vector:

         0             1
         1             0
         2             3

  Next vector:

         0            -1
         1             0
         2             3

  Next vector:

         0             1
         1            -0
         2            -3

  Next vector:

         0            -1
         1            -0
         2            -3

  Done.

TEST140
  SCHROEDER computes the Schroeder numbers.


   N    S(N)

     1       1
     2       1
     3       3
     4      11
     5      45
     6     197
     7     903
     8    4279
     9   20793
    10  103049

TEST141
  SORT_HEAP_EXTERNAL sorts objects externally.


  Before sorting:

       1         5
       2        20
       3        17
       4        12
       5         9
       6         2
       7         6
       8         3
       9         1
      10        13
      11         2
      12         9
      13         9
      14        16
      15        16
      16         1
      17        18
      18         8
      19         2
      20         1

  After sorting:

       1         1
       2         1
       3         1
       4         2
       5         2
       6         2
       7         3
       8         5
       9         6
      10         8
      11         9
      12         9
      13         9
      14        12
      15        13
      16        16
      17        16
      18        17
      19        18
      20        20

TEST142
  SUBSET_BY_SIZE_NEXT generates all subsets of an N set.

   1   1   2   3   4   5  
   2   1   2   3   4  
   3   1   2   3   5  
   4   1   2   4   5  
   5   1   3   4   5  
   6   2   3   4   5  
   7   1   2   3  
   8   1   2   4  
   9   1   2   5  
  10   1   3   4  
  11   1   3   5  
  12   1   4   5  
  13   2   3   4  
  14   2   3   5  
  15   2   4   5  
  16   3   4   5  
  17   1   2  
  18   1   3  
  19   1   4  
  20   1   5  
  21   2   3  
  22   2   4  
  23   2   5  
  24   3   4  
  25   3   5  
  26   4   5  
  27   1  
  28   2  
  29   3  
  30   4  
  31   5  
  32  The empty set

TEST143
  SUBSET_LEX_NEXT generates all subsets of an N set.
   1   1  
   2   1   2  
   3   1   2   3  
   4   1   2   3   4  
   5   1   2   3   4   5  
   6   1   2   3   5  
   7   1   2   4  
   8   1   2   4   5  
   9   1   2   5  
  10   1   3  
  11   1   3   4  
  12   1   3   4   5  
  13   1   3   5  
  14   1   4  
  15   1   4   5  
  16   1   5  
  17   2  
  18   2   3  
  19   2   3   4  
  20   2   3   4   5  
  21   2   3   5  
  22   2   4  
  23   2   4   5  
  24   2   5  
  25   3  
  26   3   4  
  27   3   4   5  
  28   3   5  
  29   4  
  30   4   5  
  31   5  
  32  The empty set.

TEST1435
  SUBSET_LEX_NEXT generates all subsets of an N set.
  The user can impose a restriction on the
  maximum size of the subsets.

  Here, we require the subsets to be no larger
  than NDIM = 3
   1  
   1   2  
   1   2   3  
   1   2   4  
   1   2   5  
   1   3  
   1   3   4  
   1   3   5  
   1   4  
   1   4   5  
   1   5  
   2  
   2   3  
   2   3   4  
   2   3   5  
   2   4  
   2   4   5  
   2   5  
   3  
   3   4  
   3   4   5  
   3   5  
   4  
   4   5  
   5  
  The empty set.

TEST144
  SUBSET_GRAY_NEXT generates all subsets of an N set
  using the Gray code ordering:
  0 0 1 0 1 means the subset contains 3 and 5.

  Gray code

   1     0 0 0 0 0
   2     1 0 0 0 0
   3     1 1 0 0 0
   4     0 1 0 0 0
   5     0 1 1 0 0
   6     1 1 1 0 0
   7     1 0 1 0 0
   8     0 0 1 0 0
   9     0 0 1 1 0
  10     1 0 1 1 0
  11     1 1 1 1 0
  12     0 1 1 1 0
  13     0 1 0 1 0
  14     1 1 0 1 0
  15     1 0 0 1 0
  16     0 0 0 1 0
  17     0 0 0 1 1
  18     1 0 0 1 1
  19     1 1 0 1 1
  20     0 1 0 1 1
  21     0 1 1 1 1
  22     1 1 1 1 1
  23     1 0 1 1 1
  24     0 0 1 1 1
  25     0 0 1 0 1
  26     1 0 1 0 1
  27     1 1 1 0 1
  28     0 1 1 0 1
  29     0 1 0 0 1
  30     1 1 0 0 1
  31     1 0 0 0 1
  32     0 0 0 0 1

TEST145
  SUBSET_RANDOM picks a subset at random.
  The number of elements in the main set is 5

   1     0 1 1 1 0
   2     0 0 0 0 1
   3     0 0 0 1 1
   4     0 1 0 0 0
   5     1 1 0 0 0

TEST146
  SUBSET_GRAY_RANK returns rank of a subset of an N set
  using the Gray code ordering.

  For N = 5, the subset is:
  1 0 1 1 0 

  The rank is 28

TEST147
  SUBSET_GRAY_UNRANK finds the subset of an N set
  of a given rank under the Gray code ordering.

  N is 5

  Rank   Subset

     1   0 0 0 0 0
     2   0 0 0 0 1
     3   0 0 0 1 1
     4   0 0 0 1 0
     5   0 0 1 1 0
     6   0 0 1 1 1
     7   0 0 1 0 1
     8   0 0 1 0 0
     9   0 1 1 0 0
    10   0 1 1 0 1

TEST1475
  SUBCOMP_NEXT generates subcompositions.

  Seek all subcompositions of N = 6
  using K = 3 parts.

     #   Sum

     1     0     0   0   0
     2     1     1   0   0
     3     1     0   1   0
     4     1     0   0   1
     5     2     2   0   0
     6     2     1   1   0
     7     2     0   2   0
     8     2     1   0   1
     9     2     0   1   1
    10     2     0   0   2
    11     3     3   0   0
    12     3     2   1   0
    13     3     1   2   0
    14     3     0   3   0
    15     3     2   0   1
    16     3     1   1   1
    17     3     0   2   1
    18     3     1   0   2
    19     3     0   1   2
    20     3     0   0   3
    21     4     4   0   0
    22     4     3   1   0
    23     4     2   2   0
    24     4     1   3   0
    25     4     0   4   0
    26     4     3   0   1
    27     4     2   1   1
    28     4     1   2   1
    29     4     0   3   1
    30     4     2   0   2
    31     4     1   1   2
    32     4     0   2   2
    33     4     1   0   3
    34     4     0   1   3
    35     4     0   0   4
    36     5     5   0   0
    37     5     4   1   0
    38     5     3   2   0
    39     5     2   3   0
    40     5     1   4   0
    41     5     0   5   0
    42     5     4   0   1
    43     5     3   1   1
    44     5     2   2   1
    45     5     1   3   1
    46     5     0   4   1
    47     5     3   0   2
    48     5     2   1   2
    49     5     1   2   2
    50     5     0   3   2
    51     5     2   0   3
    52     5     1   1   3
    53     5     0   2   3
    54     5     1   0   4
    55     5     0   1   4
    56     5     0   0   5
    57     6     6   0   0
    58     6     5   1   0
    59     6     4   2   0
    60     6     3   3   0
    61     6     2   4   0
    62     6     1   5   0
    63     6     0   6   0
    64     6     5   0   1
    65     6     4   1   1
    66     6     3   2   1
    67     6     2   3   1
    68     6     1   4   1
    69     6     0   5   1
    70     6     4   0   2
    71     6     3   1   2
    72     6     2   2   2
    73     6     1   3   2
    74     6     0   4   2
    75     6     3   0   3
    76     6     2   1   3
    77     6     1   2   3
    78     6     0   3   3
    79     6     2   0   4
    80     6     1   1   4
    81     6     0   2   4
    82     6     1   0   5
    83     6     0   1   5
    84     6     0   0   6

TEST1476
  SUBCOMPNZ_NEXT generates subcompositions using nonzero parts.

  Seek all subcompositions of N = 6
  using K = 3 nonzero parts.

     #   Sum

     1     3     1   1   1
     2     4     2   1   1
     3     4     1   2   1
     4     4     1   1   2
     5     5     3   1   1
     6     5     2   2   1
     7     5     1   3   1
     8     5     2   1   2
     9     5     1   2   2
    10     5     1   1   3
    11     6     4   1   1
    12     6     3   2   1
    13     6     2   3   1
    14     6     1   4   1
    15     6     3   1   2
    16     6     2   2   2
    17     6     1   3   2
    18     6     2   1   3
    19     6     1   2   3
    20     6     1   1   4

TEST1477
  SUBCOMPNZ2_NEXT generates subcompositions using nonzero parts.

  Seek all subcompositions of N
  using K = 3 nonzero parts.

  Here N is in the range 5 <= N <= 7

     #     N

     1     5     3   1   1
     2     5     2   2   1
     3     5     1   3   1
     4     5     2   1   2
     5     5     1   2   2
     6     5     1   1   3
     7     6     4   1   1
     8     6     3   2   1
     9     6     2   3   1
    10     6     1   4   1
    11     6     3   1   2
    12     6     2   2   2
    13     6     1   3   2
    14     6     2   1   3
    15     6     1   2   3
    16     6     1   1   4
    17     7     5   1   1
    18     7     4   2   1
    19     7     3   3   1
    20     7     2   4   1
    21     7     1   5   1
    22     7     4   1   2
    23     7     3   2   2
    24     7     2   3   2
    25     7     1   4   2
    26     7     3   1   3
    27     7     2   2   3
    28     7     1   3   3
    29     7     2   1   4
    30     7     1   2   4
    31     7     1   1   5

TEST1478
  SUBTRIANGLE_NEXT generates the indices of subtriangles
  in a triangle whose edges were divided into N subedges.

  For this test, N = 4

  Rank    I1  J1    I2  J2    I3  J3

     1     0   0     1   0     0   1
     2     1   1     0   1     1   0
     3     1   0     2   0     1   1
     4     2   1     1   1     2   0
     5     2   0     3   0     2   1
     6     3   1     2   1     3   0
     7     3   0     4   0     3   1
     8     0   1     1   1     0   2
     9     1   2     0   2     1   1
    10     1   1     2   1     1   2
    11     2   2     1   2     2   1
    12     2   1     3   1     2   2
    13     0   2     1   2     0   3
    14     1   3     0   3     1   2
    15     1   2     2   2     1   3
    16     0   3     1   3     0   4

TEST148
  THUE_BINARY_NEXT returns the next
  Thue binary sequence.

   1    0
   2    01
   4    0110
   8    01101001
  16    0110100110010110
  32    01101001100101101001011001101001
  64    0110100110010110100101100110100110010110011010010110100110010110

TEST149
  THUE_TERNARY_NEXT returns the next
  Thue ternary sequence.

   1    1
   3    102
   6    102120
  12    102120102012
  24    102120102012102120121020
  48    102120102012102120121020102120102012102010212012

TEST150
  TUPLE_NEXT returns the next "tuple", that is,
  a vector of N integers, each between M1 and M2.

  M1 = 2
  M2 = 4
  N = 2

   1   2     2  
   2   2     3  
   3   2     4  
   4   3     2  
   5   3     3  
   6   3     4  
   7   4     2  
   8   4     3  
   9   4     4  

TEST151
  TUPLE_NEXT_FAST returns the next "tuple", that is,
  a vector of N integers, each between 1 and M.

  M = 3
  N = 2

   0   1     1  
   1   1     2  
   2   1     3  
   3   2     1  
   4   2     2  
   5   2     3  
   6   3     1  
   7   3     2  
   8   3     3  

TEST152
  TUPLE_NEXT_GE returns the next nondecreasting "tuple",
  that is, a vector of N integers, each between 1 and M,
  with the additional property that the digits never decrease
  reading from left to right.

  M = 3
  N = 3

   1   1     1     1  
   2   1     1     2  
   3   1     1     3  
   4   1     2     2  
   5   1     2     3  
   6   1     3     3  
   7   2     2     2  
   8   2     2     3  
   9   2     3     3  
  10   3     3     3  

TEST153
  TUPLE_NEXT_GE returns the next "tuple",
  that is, a vector of N integers.
  Each position in the vector has a separate min and max.
  reading from left to right.

  N = 3


  The minimum values:

       1         2
       2         3
       3         8

  The maximum values:

       1         4
       2         3
       3         5


   1   2     3     8  
   2   2     3     7  
   3   2     3     6  
   4   2     3     5  
   5   3     3     8  
   6   3     3     7  
   7   3     3     6  
   8   3     3     5  
   9   4     3     8  
  10   4     3     7  
  11   4     3     6  
  12   4     3     5  

TEST1531
  UBVEC_ADD adds unsigned binary vectors 
  representing unsigned integers;

        I        J        K = I + J


        22        96
  Directly:                118
  BVEC_ADD                 118

        83        56
  Directly:                139
  BVEC_ADD                 139

        41         6
  Directly:                 47
  BVEC_ADD                  47

        26        11
  Directly:                 37
  BVEC_ADD                  37

         4        64
  Directly:                 68
  BVEC_ADD                  68

         6        45
  Directly:                 51
  BVEC_ADD                  51

        40        76
  Directly:                116
  BVEC_ADD                 116

        80         0
  Directly:                 80
  BVEC_ADD                  80

        90        35
  Directly:                125
  BVEC_ADD                 125

         9         1
  Directly:                 10
  BVEC_ADD                  10

TEST0626
  UI4_TO_UBVEC converts an unsigned integer to an 
    unsigned binary vector;
  UBVEC_TO_UI4 converts an unsigned binary vector
    to an unsigned integer;

  I --> BVEC  -->  I

  0  0000000000    0
  1  0000000001    1
  2  0000000010    2
  3  0000000011    3
  4  0000000100    4
  5  0000000101    5
  6  0000000110    6
  7  0000000111    7
  8  0000001000    8
  9  0000001001    9
 10  0000001010   10

TEST1535
  VEC_COLEX_NEXT generates all DIM_NUM-vectors
  in colex order in a given base BASE.

  The spatial dimension DIM_NUM = 3
  The base BASE =                 3

   0     0     0  
   1     0     0  
   2     0     0  
   0     1     0  
   1     1     0  
   2     1     0  
   0     2     0  
   1     2     0  
   2     2     0  
   0     0     1  
   1     0     1  
   2     0     1  
   0     1     1  
   1     1     1  
   2     1     1  
   0     2     1  
   1     2     1  
   2     2     1  
   0     0     2  
   1     0     2  
   2     0     2  
   0     1     2  
   1     1     2  
   2     1     2  
   0     2     2  
   1     2     2  
   2     2     2  

TEST1536
  VEC_COLEX_NEXT2 generates all DIM_NUM-vectors
  in colex order in a given base BASE.

  The spatial dimension DIM_NUM = 3

  The base vector:

   2     1     3  

   0     0     0  
   1     0     0  
   0     0     1  
   1     0     1  
   0     0     2  
   1     0     2  

TEST1537
  VEC_COLEX_NEXT3 generates all DIM_NUM-vectors
  in colex order in a given base BASE.

  The spatial dimension DIM_NUM = 3

  The base vector:

   2     1     3  

   1     1     1  
   2     1     1  
   1     1     2  
   2     1     2  
   1     1     3  
   2     1     3  

TEST154
  VEC_LEX_NEXT generates all DIM_NUM-vectors
  in a given base.  Here we use base 3

   0     0     0  
   0     0     1  
   0     0     2  
   0     1     0  
   0     1     1  
   0     1     2  
   0     2     0  
   0     2     1  
   0     2     2  
   1     0     0  
   1     0     1  
   1     0     2  
   1     1     0  
   1     1     1  
   1     1     2  
   1     2     0  
   1     2     1  
   1     2     2  
   2     0     0  
   2     0     1  
   2     0     2  
   2     1     0  
   2     1     1  
   2     1     2  
   2     2     0  
   2     2     1  
   2     2     2  

TEST155
  VEC_GRAY_NEXT generates product space elements.
  VEC_GRAY_RANK ranks them.
  VEC_GRAY_UNRANK unranks them.

  The number of components is 4
  The number of elements is 16
  Each component has its own number of degrees of
  freedom, which, for this example, are:

  Rank Change        2     2     1     4  

   1   0   0     0     0     0  
   2   3   0     0     0     1  
   3   3   0     0     0     2  
   4   3   0     0     0     3  
   5   1   0     1     0     3  
   6   3   0     1     0     2  
   7   3   0     1     0     1  
   8   3   0     1     0     0  
   9   0   1     1     0     0  
  10   3   1     1     0     1  
  11   3   1     1     0     2  
  12   3   1     1     0     3  
  13   1   1     0     0     3  
  14   3   1     0     0     2  
  15   3   1     0     0     1  
  16   3   1     0     0     0  

  VEC_GRAY_RANK reports the element

   1     1     0     2  

  has rank 11

  VEC_GRAY_UNRANK reports the element of rank 7  is:

   0     1     0     1  

TEST156
  VEC_RANDOM generates a random N-vector
  in a given base.
  Here, we use base 3

   1       0     2     2  
   2       1     1     0  
   3       0     0     0  
   4       1     0     1  
   5       1     2     2  

TEST1565
  VECTOR_CONSTRAINED_NEXT:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    P = Product X_MAX(1:N)
  Accept only vectors for which:
    sum ( (X(1:N)-1) * P / X_MAX(1:N) ) <= P

  X_MIN:
     2     2     1

  X_MAX:
     4     5     3

  Maximum allowed CONSTRAINT = P = 60

         1            27         2         2         1
         2            42         3         2         1
         3            57         4         2         1
         4            39         2         3         1
         5            54         3         3         1
         6            51         2         4         1
         7            47         2         2         2
         8            59         2         3         2

TEST1566
  VECTOR_CONSTRAINED_NEXT2:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    P = Product X_MAX(1:N)
  Accept only vectors for which:
    sum ( X(1:N) * P / X_MAX(1:N) ) <= P

  X_MIN:
     1     1

  X_MAX:
     5     6

  Maximum allowed CONSTRAINT = P = 30

         1            11         1         1
         2            17         2         1
         3            23         3         1
         4            29         4         1
         5            16         1         2
         6            22         2         2
         7            28         3         2
         8            21         1         3
         9            27         2         3
        10            26         1         4

  X_MIN:
     1     1     1

  X_MAX:
     5     6     4

  Maximum allowed CONSTRAINT = P = 120

         1            74         1         1         1
         2            98         2         1         1
         3            94         1         2         1
         4           118         2         2         1
         5           114         1         3         1
         6           104         1         1         2

TEST1567
  VECTOR_CONSTRAINED_NEXT3:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    CONSTRAINT = sum ( X(1:N) / X_MAX(1:N) )
  Accept only vectors for which:
    CONSTRAINT <= 1

  X_MIN:
     1     1

  X_MAX:
     5     6

         1        0.366667         1         1
         2        0.566667         2         1
         3        0.766667         3         1
         4        0.966667         4         1
         5        0.533333         1         2
         6        0.733333         2         2
         7        0.933333         3         2
         8             0.7         1         3
         9             0.9         2         3
        10        0.866667         1         4

  X_MIN:
     1     1     1

  X_MAX:
     5     6     4

         1        0.616667         1         1         1
         2        0.816667         2         1         1
         3        0.783333         1         2         1
         4        0.983333         2         2         1
         5            0.95         1         3         1
         6        0.866667         1         1         2

TEST1568
  VECTOR_CONSTRAINED_NEXT4:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    TOTAL = sum ( ALPHA(1:N) * X(1:N) )
  Accept only vectors for which:
    TOTAL <= Q

  ALPHA:         4         3
  Q:            20
  X_MIN:     1     0
  X_MAX:     2     6

         1               4         1         0
         2               8         2         0
         3               7         1         1
         4              11         2         1
         5              10         1         2
         6              14         2         2
         7              13         1         3
         8              17         2         3
         9              16         1         4
        10              20         2         4
        11              19         1         5

  ALPHA:         4         3         5
  Q:            20
  X_MIN:     1     0     1
  X_MAX:     2     6     4

         1               9         1         0         1
         2              13         2         0         1
         3              12         1         1         1
         4              16         2         1         1
         5              15         1         2         1
         6              19         2         2         1
         7              18         1         3         1
         8              14         1         0         2
         9              18         2         0         2
        10              17         1         1         2
        11              20         1         2         2
        12              19         1         0         3

TEST1569
  VECTOR_CONSTRAINED_NEXT5:
  Generate integer vectors X such that:
    SUM_MIN <= sum ( X(1:N) ) <= SUM_MAX,
  We require every X(I) to be at least 1.

  N =       3
  SUM_MIN = 5
  SUM_MAX = 7

         #        X(1)      X(2)      X(3)

         1         3         1         1
         2         2         2         1
         3         2         1         2
         4         1         3         1
         5         1         2         2
         6         1         1         3
         7         4         1         1
         8         3         2         1
         9         3         1         2
        10         2         3         1
        11         2         2         2
        12         2         1         3
        13         1         4         1
        14         1         3         2
        15         1         2         3
        16         1         1         4
        17         5         1         1
        18         4         2         1
        19         4         1         2
        20         3         3         1
        21         3         2         2
        22         3         1         3
        23         2         4         1
        24         2         3         2
        25         2         2         3
        26         2         1         4
        27         1         5         1
        28         1         4         2
        29         1         3         3
        30         1         2         4
        31         1         1         5

TEST15695
  VECTOR_CONSTRAINED_NEXT6:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    TOTAL = sum ( ALPHA(1:N) * X(1:N) )
  Accept only vectors for which:
    Q_MIN <= TOTAL <= Q_MAX

  ALPHA:         4         3
  Q_MIN:        16
  Q_MAX:        20
  X_MIN:     1     0
  X_MAX:     2     6

         1              16         1         4
         2              19         1         5
         3              17         2         3
         4              20         2         4

  ALPHA:         4         3         5
  Q_MIN:        16
  Q_MAX:        20
  X_MIN:     1     0     1
  X_MAX:     2     6     4

         1              19         1         0         3
         2              17         1         1         2
         3              20         1         2         2
         4              18         1         3         1
         5              18         2         0         2
         6              16         2         1         1
         7              19         2         2         1

TEST15696
  VECTOR_CONSTRAINED_NEXT7:
  Consider vectors:
    0 <= X(1:N) <= X_MAX(1:N),
  Set
    TOTAL = sum ( ALPHA(1:N) * X(1:N) )
  Accept only vectors for which:
    Q_MIN <= TOTAL <= Q_MAX

  ALPHA:         4         3
  Q_MIN:        16
  Q_MAX:        20
  X_MAX:     2     6

         1              18         0         6
         2              19         1         5
         3              17         2         3
         4              20         2         4

  ALPHA:         4         3         5
  Q_MIN:        16
  Q_MAX:        20
  X_MAX:     2     6     4

         1              20         0         0         4
         2              18         0         1         3
         3              19         0         3         2
         4              17         0         4         1
         5              20         0         5         1
         6              18         0         6         0
         7              19         1         0         3
         8              17         1         1         2
         9              20         1         2         2
        10              18         1         3         1
        11              19         1         5         0
        12              18         2         0         2
        13              19         2         2         1
        14              17         2         3         0
        15              20         2         4         0

TEST15698
  VECTOR_NEXT:
  Generate all vectors X such that:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),

    X_MIN:         1         4
         1         1         4
         2         2         4
         3         1         5
         4         2         5
         5         1         6
         6         2         6
    X_MAX:         2         6

    X_MIN:         1         4         3
         1         1         4         3
         2         2         4         3
         3         1         5         3
         4         2         5         3
         5         1         6         3
         6         2         6         3
         7         1         4         4
         8         2         4         4
         9         1         5         4
        10         2         5         4
        11         1         6         4
        12         2         6         4
    X_MAX:         2         6         4

TEST157
  YTB_ENUM counts Young tableau.

   N  YTB_ENUM(N)

   0           0
   1           1
   2           2
   3           4
   4          10
   5          26
   6          76
   7         232
   8         764
   9        2620
  10        9496

TEST158
  YTB_NEXT generates Young tableaus.


 

     1       4       6  
     2       5  
     3  

 

     1       3       6  
     2       5  
     4  

 

     1       2       6  
     3       5  
     4  

 

     1       3       6  
     2       4  
     5  

 

     1       2       6  
     3       4  
     5  

 

     1       4       5  
     2       6  
     3  

 

     1       3       5  
     2       6  
     4  

 

     1       2       5  
     3       6  
     4  

 

     1       3       4  
     2       6  
     5  

 

     1       2       4  
     3       6  
     5  

 

     1       2       3  
     4       6  
     5  

 

     1       3       5  
     2       4  
     6  

 

     1       2       5  
     3       4  
     6  

 

     1       3       4  
     2       5  
     6  

 

     1       2       4  
     3       5  
     6  

 

     1       2       3  
     4       5  
     6  

TEST159
  YTB_RANDOM generates a random Young tableau

 

     1       2       6  
     3       5  
     4  

 

     1       3       6  
     2       4  
     5  

 

     1       3       6  
     2       4  
     5  

 

     1       3       5  
     2       4  
     6  

 

     1       2       5  
     3       4  
     6  

SUBSET_PRB
  Normal end of execution.

11 December 2013 11:37:51 PM
